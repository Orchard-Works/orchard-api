================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-10-14T12:32:23.320Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.github/
  workflows/
    deploy.yml
config/
  admin.js
  api.js
  database.js
  middlewares.js
  plugins.js
  server.js
public/
  robots.txt
src/
  admin/
    app.example.js
    webpack.config.example.js
  api/
    channel/
      content-types/
        channel/
          schema.json
      controllers/
        channel.js
      routes/
        channel.js
      services/
        channel.js
    channel-invitation/
      content-types/
        channel-invitation/
          schema.json
      controllers/
        channel-invitation.js
      routes/
        channel-invitation.js
      services/
        channel-invitation.js
    country/
      content-types/
        country/
          schema.json
      controllers/
        country.js
      routes/
        country.js
      services/
        country.js
    invitation/
      content-types/
        invitation/
          schema.json
      controllers/
        invitation.js
      routes/
        invitation.js
      services/
        invitation.js
    organisation/
      content-types/
        organisation/
          schema.json
      controllers/
        organisation.js
      routes/
        organisation.js
      services/
        organisation.js
    seat-type/
      content-types/
        seat-type/
          schema.json
      controllers/
        seat-type.js
      routes/
        seat-type.js
      services/
        seat-type.js
    series/
      content-types/
        series/
          schema.json
      controllers/
        series.js
      routes/
        series.js
      services/
        series.js
  extensions/
    users-permissions/
      content-types/
        user/
          schema.json
  index.js
types/
  generated/
    components.d.ts
    contentTypes.d.ts
.editorconfig
.env.example
.eslintignore
.eslintrc
.gitignore
docker-compose.yml
Dockerfile
jsconfig.json
package.json
README.md

================================================================
Repository Files
================================================================

================
File: .github/workflows/deploy.yml
================
name: Deploy to Ubuntu Server

on:
  push:
    branches:
      - main

env:
  REGISTRY: ghcr.io

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set lowercase image name
        run: |
          echo "IMAGE_NAME=$(echo ${{ github.repository }} | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest,enable={{is_default_branch}}
            type=sha,format=long

      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Verify image push
        run: |
          echo "Image tags:"
          echo "${{ steps.meta.outputs.tags }}"
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          docker image ls

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set lowercase image name
        run: |
          echo "IMAGE_NAME=$(echo ${{ github.repository }} | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: Install SSH key
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.SERVER_SSH_KEY }}
          known_hosts: ${{ secrets.KNOWN_HOSTS }}

      - name: Deploy to Ubuntu server
        env:
          HOST: ${{ secrets.HOST }}
          USER: ${{ secrets.USER }}
          GITHUB_TOKEN: ${{ secrets.GHCR_PAT }}
          DATABASE_CLIENT: ${{ secrets.DATABASE_CLIENT }}
          DATABASE_HOST: ${{ secrets.DATABASE_HOST }}
          DATABASE_PORT: ${{ secrets.DATABASE_PORT }}
          DATABASE_NAME: ${{ secrets.DATABASE_NAME }}
          DATABASE_USERNAME: ${{ secrets.DATABASE_USERNAME }}
          DATABASE_PASSWORD: ${{ secrets.DATABASE_PASSWORD }}
          DATABASE_SSL: ${{ secrets.DATABASE_SSL }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          ADMIN_JWT_SECRET: ${{ secrets.ADMIN_JWT_SECRET }}
          APP_KEYS: ${{ secrets.APP_KEYS }}
          API_TOKEN_SALT: ${{ secrets.API_TOKEN_SALT }}
          SENDGRID_API_KEY: ${{ secrets.SENDGRID_API_KEY }}
          STRAPI_ADMIN_URL: ${{ secrets.STRAPI_ADMIN_URL }}
          PUBLIC_URL: ${{ secrets.PUBLIC_URL }}
          ADMIN_URL: ${{ secrets.ADMIN_URL }}
          STRAPI_ADMIN_BACKEND_URL: ${{ secrets.STRAPI_ADMIN_BACKEND_URL }}
          ADMIN_PATH: ${{ secrets.ADMIN_PATH }}
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
        run: |
          sed -i 's|${GITHUB_REPOSITORY}|${{ env.IMAGE_NAME }}|g' docker-compose.yml
          scp docker-compose.yml $USER@$HOST:/opt/apps/orchard-backend/
          ssh $USER@$HOST << EOF
            cd /opt/apps/orchard-backend
            echo "$GITHUB_TOKEN" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            export DATABASE_CLIENT="${DATABASE_CLIENT}"
            export DATABASE_HOST="${DATABASE_HOST}"
            export DATABASE_PORT="${DATABASE_PORT}"
            export DATABASE_NAME="${DATABASE_NAME}"
            export DATABASE_USERNAME="${DATABASE_USERNAME}"
            export DATABASE_PASSWORD="${DATABASE_PASSWORD}"
            export DATABASE_SSL="${DATABASE_SSL}"
            export JWT_SECRET="${JWT_SECRET}"
            export ADMIN_JWT_SECRET="${ADMIN_JWT_SECRET}"
            export APP_KEYS="${APP_KEYS}"
            export API_TOKEN_SALT="${API_TOKEN_SALT}"
            export SENDGRID_API_KEY="${SENDGRID_API_KEY}"
            export STRAPI_ADMIN_URL="${STRAPI_ADMIN_URL}"
            export PUBLIC_URL="${PUBLIC_URL}"
            export ADMIN_URL="${ADMIN_URL}"
            export ADMIN_PATH="${ADMIN_PATH}"
            export STRAPI_ADMIN_BACKEND_URL="${STRAPI_ADMIN_BACKEND_URL}"
            export FRONTEND_URL="${FRONTEND_URL}"
            docker-compose pull
            docker-compose up -d
            docker logout ghcr.io
          EOF

================
File: config/admin.js
================
module.exports = ({ env }) => ({
  auth: {
    secret: "tobemodified",
  },
  apiToken: {
    salt: "tobemodified",
  },
  transfer: {
    token: {
      salt: "tobemodified",
    },
  },
  flags: {
    nps: true,
    promoteEE: true,
  },
});

================
File: config/api.js
================
module.exports = {
  rest: {
    defaultLimit: 25,
    maxLimit: 100,
    withCount: true,
  },
};

================
File: config/database.js
================
const path = require('path');

module.exports = ({ env }) => {
  const client = 'postgres';

  const connections = {
    postgres: {
      connection: {
        host: env('DATABASE_HOST', '127.0.0.1'),
        port: env.int('DATABASE_PORT', 5432),
        database: env('DATABASE_NAME', 'strapi'),
        user: env('DATABASE_USERNAME', 'strapi'),
        password: env('DATABASE_PASSWORD', 'strapi'),
        ssl: env.bool('DATABASE_SSL', false),
        schema: env('DATABASE_SCHEMA', 'public'),
      },
      pool: { min: env.int('DATABASE_POOL_MIN', 2), max: env.int('DATABASE_POOL_MAX', 10) },
    },
  };

  return {
    connection: {
      client,
      ...connections[client],
      acquireConnectionTimeout: env.int('DATABASE_CONNECTION_TIMEOUT', 60000),
    },
  };
};

================
File: config/middlewares.js
================
module.exports = [
  'strapi::errors',
  {
    name: 'strapi::security',
    config: {
      contentSecurityPolicy: {
        useDefaults: true,
        directives: {
          'connect-src': ["'self'", 'https:', 'http:', 'ws:', 'wss:'],
        },
      },
    },
  },
  'strapi::security',
  'strapi::cors',
  'strapi::poweredBy',
  'strapi::logger',
  'strapi::query',
  'strapi::body',
  'strapi::session',
  'strapi::favicon',
  'strapi::public',
];

================
File: config/plugins.js
================
module.exports = ({env}) => ({
  email: {
    config: {
      provider: "sendgrid",
      providerOptions: {
        apiKey: env("SENDGRID_API_KEY"),
      },
      settings: {
        defaultFrom: "dean@harvestanimation.com",
        defaultReplyTo: "dean@harvestanimation.com",
      },
    },
  },
});

================
File: config/server.js
================
module.exports = ({ env }) => ({
  host: env('HOST', '0.0.0.0'),
  port: env.int('PORT', 1337),
  app: {
    keys: env.array('APP_KEYS'),
  },
  webhooks: {
    populateRelations: env.bool('WEBHOOKS_POPULATE_RELATIONS', false),
  },
  url: env('PUBLIC_URL', 'https://orchard-backend.deant.work'),
  admin: {
    url: env('ADMIN_PATH', '/admin'),
    auth: {
      secret: env('ADMIN_JWT_SECRET'),
    },
  },
  frontendUrl: env('FRONTEND_URL', 'http://localhost:3000'),
});

================
File: public/robots.txt
================
# To prevent search engines from seeing the site altogether, uncomment the next two lines:
# User-Agent: *
# Disallow: /

================
File: src/admin/app.example.js
================
const config = {
  locales: [
    // 'ar',
    // 'fr',
    // 'cs',
    // 'de',
    // 'dk',
    // 'es',
    // 'he',
    // 'id',
    // 'it',
    // 'ja',
    // 'ko',
    // 'ms',
    // 'nl',
    // 'no',
    // 'pl',
    // 'pt-BR',
    // 'pt',
    // 'ru',
    // 'sk',
    // 'sv',
    // 'th',
    // 'tr',
    // 'uk',
    // 'vi',
    // 'zh-Hans',
    // 'zh',
  ],
};

const bootstrap = (app) => {
  console.log(app);
};

export default {
  config,
  bootstrap,
};

================
File: src/admin/webpack.config.example.js
================
'use strict';

/* eslint-disable no-unused-vars */
module.exports = (config, webpack) => {
  // Note: we provide webpack above so you should not `require` it
  // Perform customizations to webpack config
  // Important: return the modified config
  return config;
};

================
File: src/api/channel/content-types/channel/schema.json
================
{
  "kind": "collectionType",
  "collectionName": "channels",
  "info": {
    "singularName": "channel",
    "pluralName": "channels",
    "displayName": "Channel",
    "description": ""
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {
    "lifecycles": {
      "enabled": true
    }
  },
  "attributes": {
    "name": {
      "type": "string"
    },
    "description": {
      "type": "text"
    },
    "organisation": {
      "type": "relation",
      "relation": "manyToOne",
      "target": "api::organisation.organisation",
      "inversedBy": "channels"
    },
    "users": {
      "type": "relation",
      "relation": "oneToMany",
      "target": "plugin::users-permissions.user"
    },
    "invitations": {
      "type": "relation",
      "relation": "oneToMany",
      "target": "api::channel-invitation.channel-invitation",
      "mappedBy": "channel"
    },
    "isInternal": {
      "type": "boolean",
      "default": false
    },
    "series": {
      "type": "relation",
      "relation": "oneToMany",
      "target": "api::series.series",
      "mappedBy": "channel"
    }
  }
}

================
File: src/api/channel/controllers/channel.js
================
'use strict';

/**
 * channel controller
 */

const {createCoreController} = require('@strapi/strapi').factories;
const crypto = require('crypto');


module.exports = createCoreController('api::channel.channel', ({strapi}) => ({
  // Find all channels
  async find(ctx) {
    try {
      const channels = await strapi.entityService.findMany('api::channel.channel', {
        ...ctx.query,
      });
      return channels;
    } catch (err) {
      ctx.throw(500, err);
    }
  },

  // Find a specific channel
  async findOne(ctx) {
    try {
      const {id} = ctx.params;
      const channel = await strapi.entityService.findOne('api::channel.channel', id, {
        ...ctx.query,
      });
      if (!channel) return ctx.notFound();
      return channel;
    } catch (err) {
      ctx.throw(500, err);
    }
  },

  // Create a new channel
  async create(ctx) {
    const {name, description, organisationId, isInternal, invitedEmails} = ctx.request.body;

    // Create the channel
    const channel = await strapi.entityService.create('api::channel.channel', {
      data: {
        name,
        description,
        organisation: organisationId,
        isInternal,
        publishedAt: new Date(),
      },
    });

    // Send invitations
    if (invitedEmails && invitedEmails.length > 0) {
      for (const email of invitedEmails) {
        try {
          const token = crypto.randomBytes(32).toString('hex');

          // Create the invitation link
          const invitationLink = `${strapi.config.get('server.frontendUrl')}/channel-invite/${token}`;
          const emailHtml = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Channel Invitation</title>
</head>
<body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
    <div style="background-color: #f0f7ff; border-radius: 10px; padding: 20px; text-align: center;">
        <img src="https://i.ibb.co/gyLFyZ2/logo-1.png" alt="Orchard Logo" style="width: 50px; margin-bottom: 20px;">
        <h1 style="color: orange; margin-bottom: 20px;">You're Invited!</h1>
        <p style="font-size: 18px; margin-bottom: 30px;">
            You've been invited to join the channel <strong style="color: #0066cc;">"${name}"</strong>.
        </p>
        <a href="${invitationLink}" style="background-color: orange; color: white; padding: 12px 24px; text-decoration: none; border-radius: 5px; font-weight: bold; font-size: 16px;">Accept Invitation</a>
    </div>
    <div style="margin-top: 30px; text-align: center; color: #666;">
        <p>If you have any questions, please don't hesitate to contact us.</p>
        <p>© ${new Date().getFullYear()} Orchard.works. All rights reserved.</p>
    </div>
</body>
</html>
`;


          await strapi.plugins['email'].services.email.send({
            to: email,
            subject: `Invitation to join channel "${name}"`,
            text: `You've been invited to join the channel "${name}". Click here to accept: ${invitationLink}`,
            html: emailHtml
          });

          // Create an invitation record in the database
          await strapi.entityService.create('api::channel-invitation.channel-invitation', {
            data: {
              email,
              channel: channel.id,
              status: 'pending',
              token,
            },
          });
        } catch (error) {
          console.error(`Failed to send invitation email to ${email}:`, error);
        }
      }
    }

    return channel;
  },

  // Update a channel
  async update(ctx) {
    try {
      const {id} = ctx.params;
      const updateData = ctx.request.body;
      const updatedChannel = await strapi.entityService.update('api::channel.channel', id, {
        data: updateData,
      });
      return updatedChannel;
    } catch (err) {
      ctx.throw(500, err);
    }
  },

  // Delete a channel
  async delete(ctx) {
    try {
      const {id} = ctx.params;
      const deletedChannel = await strapi.entityService.delete('api::channel.channel', id);
      return deletedChannel;
    } catch (err) {
      ctx.throw(500, err);
    }
  },

  // Accept invitation to a channel
  async acceptInvitation(ctx) {
    const {token} = ctx.params;
    const user = ctx.state.user;


    const invitation = await strapi.entityService.findMany('api::channel-invitation.channel-invitation', {
      filters: {token},
      populate: ['channel'],
    });

    if (!invitation || invitation.length === 0) {
      return ctx.notFound('Invitation not found');
    }

    const channelInvitation = invitation[0];

    if (channelInvitation.status !== 'pending') {
      return ctx.badRequest('This invitation has already been processed');
    }

    if (!user) {
      return {
        status: 'unauthenticated',
        email: channelInvitation.email,
        channelName: channelInvitation.channel.name,
        organisationId: channelInvitation.channel.organisation.id,
      };
    }

    await strapi.entityService.update('api::channel-invitation.channel-invitation', channelInvitation.id, {
      data: {status: 'accepted'},
    });

    await strapi.entityService.update('api::channel.channel', channelInvitation.channel.id, {
      data: {users: {connect: [user.id]}},
    });

    return {status: 'accepted', message: 'Invitation accepted successfully'};
  },
  async checkInvitation(ctx) {
    const {token} = ctx.params;

    const invitation = await strapi.entityService.findMany('api::channel-invitation.channel-invitation', {
      filters: {token},
      populate: ['channel.organisation'],
    });

    if (!invitation || invitation.length === 0) {
      return ctx.notFound('Invitation not found');
    }

    const channelInvitation = invitation[0];

    if (channelInvitation.status !== 'pending') {
      return ctx.badRequest('This invitation has already been processed');
    }

    if (!ctx.state.user) {
      return {
        status: 'unauthenticated',
        email: channelInvitation.email,
        channelName: channelInvitation.channel.name,
        organisationName: channelInvitation.channel.organisation.name,
      };
    }

    return {status: 'authenticated'};
  },
  async inviteUsers(ctx) {
    const {id} = ctx.params;
    const {emails} = ctx.request.body;

    const channel = await strapi.entityService.findOne('api::channel.channel', id, {
      populate: ['organisation'],
    });

    if (!channel) {
      return ctx.notFound('Channel not found');
    }

    for (const email of emails) {
      try {
        const token = crypto.randomBytes(32).toString('hex');
        const invitationLink = `${strapi.config.get('server.frontendUrl')}/channel-invite/${token}`;
        const emailHtml = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Channel Invitation</title>
</head>
<body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
    <div style="background-color: #f0f7ff; border-radius: 10px; padding: 20px; text-align: center;">
        <img src="https://i.ibb.co/gyLFyZ2/logo-1.png" alt="Orchard Logo" style="width: 50px; margin-bottom: 20px;">
        <h1 style="color: orange; margin-bottom: 20px;">You're Invited!</h1>
        <p style="font-size: 18px; margin-bottom: 30px;">
            You've been invited to join the channel <strong style="color: #0066cc;">"${channel.name}"</strong>.
        </p>
        <a href="${invitationLink}" style="background-color: orange; color: white; padding: 12px 24px; text-decoration: none; border-radius: 5px; font-weight: bold; font-size: 16px;">Accept Invitation</a>
    </div>
    <div style="margin-top: 30px; text-align: center; color: #666;">
        <p>If you have any questions, please don't hesitate to contact us.</p>
        <p>© ${new Date().getFullYear()} Orchard.works. All rights reserved.</p>
    </div>
</body>
</html>
`;


        await strapi.plugins['email'].services.email.send({
          to: email,
          subject: `Invitation to join channel "${channel.name}"`,
          html: emailHtml,
        });


        await strapi.entityService.create('api::channel-invitation.channel-invitation', {
          data: {
            email,
            channel: id,
            status: 'pending',
            token,
          },
        });
      } catch (error) {
        console.error(`Failed to send invitation email to ${email}:`, error);
      }
    }

    return {message: 'Invitations sent successfully'};
  },
}));

================
File: src/api/channel/routes/channel.js
================
'use strict';

module.exports = {
  routes: [
    {
      method: 'GET',
      path: '/channels',
      handler: 'channel.find',
      config: {
        policies: [],
        middlewares: [],
      },
    },
    {
      method: 'GET',
      path: '/channels/:id',
      handler: 'channel.findOne',
      config: {
        policies: [],
        middlewares: [],
      },
    },
    {
      method: 'POST',
      path: '/channels',
      handler: 'channel.create',
      config: {
        policies: [],
        middlewares: [],
      },
    },
    {
      method: 'PUT',
      path: '/channels/:id',
      handler: 'channel.update',
      config: {
        policies: [],
        middlewares: [],
      },
    },
    {
      method: 'DELETE',
      path: '/channels/:id',
      handler: 'channel.delete',
      config: {
        policies: [],
        middlewares: [],
      },
    },

    {
      method: 'POST',
      path: '/channels/accept-invitation/:token',
      handler: 'channel.acceptInvitation',
      config: {
        policies: [],
        middlewares: [],
      },
    },
    {
      method: 'GET',
      path: '/channels/check-invitation/:token',
      handler: 'channel.checkInvitation',
      config: {
        auth: false,
        policies: [],
      },
    },
    {
      method: 'POST',
      path: '/channels/:id/invite',
      handler: 'channel.inviteUsers',
      config: {
        policies: [],
        middlewares: [],
      },
    },
  ],
};

================
File: src/api/channel/services/channel.js
================
'use strict';

/**
 * channel service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::channel.channel');

================
File: src/api/channel-invitation/content-types/channel-invitation/schema.json
================
{
  "kind": "collectionType",
  "collectionName": "channel_invitations",
  "info": {
    "singularName": "channel-invitation",
    "pluralName": "channel-invitations",
    "displayName": "Channel Invitation"
  },
  "options": {
    "draftAndPublish": false
  },
  "attributes": {
    "email": {
      "type": "email",
      "required": true
    },
    "channel": {
      "type": "relation",
      "relation": "manyToOne",
      "target": "api::channel.channel",
      "inversedBy": "invitations"
    },
    "status": {
      "type": "enumeration",
      "enum": [
        "pending",
        "accepted",
        "rejected"
      ],
      "default": "pending"
    },
    "token": {
      "type": "string",
      "unique": true
    },
    "invitedBy": {
      "type": "relation",
      "relation": "manyToOne",
      "target": "plugin::users-permissions.user"
    }
  }
}

================
File: src/api/channel-invitation/controllers/channel-invitation.js
================
'use strict';

/**
 * channel-invitation controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::channel-invitation.channel-invitation');

================
File: src/api/channel-invitation/routes/channel-invitation.js
================
'use strict';

/**
 * channel-invitation router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::channel-invitation.channel-invitation');

================
File: src/api/channel-invitation/services/channel-invitation.js
================
'use strict';

/**
 * channel-invitation service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::channel-invitation.channel-invitation');

================
File: src/api/country/content-types/country/schema.json
================
{
  "kind": "collectionType",
  "collectionName": "countries",
  "info": {
    "singularName": "country",
    "pluralName": "countries",
    "displayName": "Country"
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "name": {
      "type": "string"
    }
  }
}

================
File: src/api/country/controllers/country.js
================
'use strict';

/**
 * country controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::country.country');

================
File: src/api/country/routes/country.js
================
'use strict';

/**
 * country router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::country.country');

================
File: src/api/country/services/country.js
================
'use strict';

/**
 * country service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::country.country');

================
File: src/api/invitation/content-types/invitation/schema.json
================
{
  "kind": "collectionType",
  "collectionName": "invitations",
  "info": {
    "singularName": "invitation",
    "pluralName": "invitations",
    "displayName": "Invitation",
    "description": "Invitations for organizations, channels, and series"
  },
  "options": {
    "draftAndPublish": false
  },
  "attributes": {
    "email": {
      "type": "email",
      "required": true
    },
    "status": {
      "type": "enumeration",
      "enum": [
        "pending",
        "accepted",
        "rejected"
      ],
      "default": "pending"
    },
    "token": {
      "type": "string",
      "unique": true
    },
    "invitedBy": {
      "type": "relation",
      "relation": "manyToOne",
      "target": "plugin::users-permissions.user"
    },
    "organisation": {
      "type": "relation",
      "relation": "manyToOne",
      "target": "api::organisation.organisation"
    },
    "channel": {
      "type": "relation",
      "relation": "manyToOne",
      "target": "api::channel.channel"
    },
    "series": {
      "type": "relation",
      "relation": "manyToOne",
      "target": "api::series.series"
    },
    "invitationType": {
      "type": "enumeration",
      "enum": [
        "organisation",
        "channel",
        "series"
      ],
      "required": true
    }
  }
}

================
File: src/api/invitation/controllers/invitation.js
================
const { createCoreController } = require('@strapi/strapi').factories;
const crypto = require('crypto');

module.exports = createCoreController('api::invitation.invitation', ({ strapi }) => ({
  async create(ctx) {
    const { emails, invitationType, targetId } = ctx.request.body;
    const user = ctx.state.user;

    if (!user) {
      return ctx.unauthorized('You must be logged in to create invitations');
    }

    if (!Array.isArray(emails) || emails.length === 0) {
      return ctx.badRequest('Emails must be provided as a non-empty array');
    }

    const invitations = [];

    for (const email of emails) {
      const invitationData = {
        email,
        invitationType,
        invitedBy: user.id,
        status: 'pending',
        token: crypto.randomBytes(32).toString('hex')
      };

      switch (invitationType) {
        case 'organisation':
          invitationData.organisation = targetId;
          break;
        case 'channel':
          invitationData.channel = targetId;
          break;
        case 'series':
          invitationData.series = targetId;
          break;
        default:
          return ctx.badRequest('Invalid invitation type');
      }

      const invitation = await strapi.entityService.create('api::invitation.invitation', {
        data: invitationData,
        populate: ['organisation', 'channel', 'series']
      });
      invitations.push(invitation);

      // Send invitation email
      await this.sendInvitationEmail(invitation);
    }

    return { invitations };
  },

  async accept(ctx) {
    const { token } = ctx.params;
    const user = ctx.state.user;

    if (!user) {
      return ctx.unauthorized('You must be logged in to accept an invitation');
    }

    console.log(token)

    const invitation = await strapi.entityService.findMany('api::invitation.invitation', {
      filters: { token: token },
      populate: ['organisation', 'channel', 'series'],
    });

    if (!invitation || invitation.length === 0) {
      return ctx.notFound('Invitation not found');
    }

    const invitationData = invitation[0];

    if (invitationData.status !== 'pending') {
      return ctx.badRequest('This invitation has already been processed');
    }

    // Update invitation status
    await strapi.entityService.update('api::invitation.invitation', invitationData.id, { data: { status: 'accepted' } });

    switch (invitationData.invitationType) {
      case 'organisation':
        await this.addUserToOrganisation(user.id, invitationData.organisation.id);
        break;
      case 'channel':
        await this.addUserToChannel(user.id, invitationData.channel.id);
        break;
      case 'series':
        await this.addUserToSeries(user.id, invitationData.series.id);
        break;
    }

    return { message: 'Invitation accepted successfully' };
  },

  async addUserToOrganisation(userId, organisationId) {
    // Add user to the organization
    await strapi.entityService.update('api::organisation.organisation', organisationId, {
      data: { users: { connect: [userId] } }
    });

    // Find all channels associated with this organization
    const channels = await strapi.entityService.findMany('api::channel.channel', {
      filters: { organisation: organisationId },
    });

    // Add user to all channels of the organization
    for (const channel of channels) {
      await this.addUserToChannel(userId, channel.id);
    }
  },

  async addUserToChannel(userId, channelId) {
    await strapi.entityService.update('api::channel.channel', channelId, {
      data: { users: { connect: [userId] } }
    });
  },

  async addUserToSeries(userId, seriesId) {
    await strapi.entityService.update('api::series.series', seriesId, {
      data: { users: { connect: [userId] } }
    });
  },

  async sendInvitationEmail(invitation) {
    let targetName, invitationLink;

    switch (invitation.invitationType) {
      case 'organisation':
        targetName = invitation.organisation.name;
        invitationLink = `${strapi.config.get('server.frontendUrl')}/invite/organisation/${invitation.token}`;
        break;
      case 'channel':
        targetName = invitation.channel.name;
        invitationLink = `${strapi.config.get('server.frontendUrl')}/invite/channel/${invitation.token}`;
        break;
      case 'series':
        targetName = invitation.series.name;
        invitationLink = `${strapi.config.get('server.frontendUrl')}/invite/series/${invitation.token}`;
        break;
    }

    const emailTemplate = `
      <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Invitation to Orchard.works</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }
        .container {
            background-color: #f0f7ff;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
        }
        .logo {
            width: 100px;
            margin-bottom: 20px;
        }
        h1 {
            color: #f5755a;
            margin-bottom: 20px;
        }
        .button {
            display: inline-block;
            background-color: #f5755a;
            color: white;
            padding: 12px 24px;
            text-decoration: none;
            border-radius: 5px;
            font-weight: bold;
            margin-top: 20px;
        }
        .footer {
            margin-top: 30px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>You're Invited!</h1>
        <p>You've been invited to join <strong>${targetName}</strong> on Orchard.works, the Intelligent Visual Data Platform.</p>
        <p>Orchard.works enables effective communication, training, and education through visual artifacts such as animations and infographics.</p>
        <a href="${invitationLink}" class="button" style="color: white">Accept Invitation</a>
    </div>
    <div class="footer">
        <p>If you have any questions, please don't hesitate to contact us.</p>
        <p>© ${new Date().getFullYear()} Orchard.works. All rights reserved.</p>
    </div>
</body>
</html>
    `;

    await strapi.plugins['email'].services.email.send({
      to: invitation.email,
      subject: `Invitation to join ${targetName} on Orchard.works`,
      html: emailTemplate,
    });
  },

  async checkInvitation(ctx) {
    const { token } = ctx.params;

    try {
      const invitation = await strapi.entityService.findMany('api::invitation.invitation', {
        filters: { token: token },
        populate: ['organisation', 'channel', 'series'],
      });

      if (!invitation || invitation.length === 0) {
        return ctx.notFound('Invitation not found');
      }

      const invitationData = invitation[0];

      if (invitationData.status !== 'pending') {
        return ctx.badRequest('This invitation has already been processed');
      }

      let entityName, entityType;
      switch (invitationData.invitationType) {
        case 'organisation':
          entityName = invitationData.organisation.name;
          entityType = 'Organisation';
          break;
        case 'channel':
          entityName = invitationData.channel.name;
          entityType = 'Channel';
          break;
        case 'series':
          entityName = invitationData.series.name;
          entityType = 'Series';
          break;
        default:
          return ctx.badRequest('Invalid invitation type');
      }

      return {
        email: invitationData.email,
        entityName,
        entityType,
        invitationType: invitationData.invitationType,
      };

    } catch (err) {
      ctx.throw(500, 'Error checking invitation');
    }
  },
}));

================
File: src/api/invitation/routes/invitation.js
================
'use strict';
'use strict';

module.exports = {
  routes: [
    {
      method: 'GET',
      path: '/invitations',
      handler: 'invitation.find',
      config: {
        policies: [],
        middlewares: [],
      },
    },
    {
      method: 'POST',
      path: '/invitations',
      handler: 'invitation.create',
      config: {
        policies: [],
        middlewares: [],
      },
    },
    {
      method: 'GET',
      path: '/invitations/check/:token',
      handler: 'invitation.checkInvitation',
      config: {
        auth: false,
        policies: [],
      },
    },
    {
      method: 'POST',
      path: '/invitations/accept/:token',
      handler: 'invitation.accept',
      config: {
        policies: [],
      },
    },
  ],
};

================
File: src/api/invitation/services/invitation.js
================
'use strict';

/**
 * invitation service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::invitation.invitation');

================
File: src/api/organisation/content-types/organisation/schema.json
================
{
  "kind": "collectionType",
  "collectionName": "organisations",
  "info": {
    "singularName": "organisation",
    "pluralName": "organisations",
    "displayName": "Organisation",
    "description": ""
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "name": {
      "type": "string"
    },
    "description": {
      "type": "text"
    },
    "size": {
      "type": "string"
    },
    "location": {
      "type": "string"
    },
    "users": {
      "type": "relation",
      "relation": "manyToMany",
      "target": "plugin::users-permissions.user",
      "inversedBy": "organisations"
    },
    "seat_type": {
      "type": "relation",
      "relation": "oneToOne",
      "target": "api::seat-type.seat-type"
    },
    "country": {
      "type": "string"
    },
    "admins": {
      "type": "relation",
      "relation": "manyToMany",
      "target": "plugin::users-permissions.user",
      "inversedBy": "adminOf"
    },
    "invitations": {
      "type": "relation",
      "relation": "oneToMany",
      "target": "api::invitation.invitation",
      "mappedBy": "organisation"
    },
    "channels": {
      "type": "relation",
      "relation": "oneToMany",
      "target": "api::channel.channel",
      "mappedBy": "organisation"
    },
    "series": {
      "type": "relation",
      "relation": "oneToMany",
      "target": "api::series.series",
      "mappedBy": "organisation"
    }
  }
}

================
File: src/api/organisation/controllers/organisation.js
================
'use strict';

/**
 * organisation controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::organisation.organisation');

================
File: src/api/organisation/routes/organisation.js
================
'use strict';

/**
 * organisation router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::organisation.organisation');

================
File: src/api/organisation/services/organisation.js
================
'use strict';

/**
 * organisation service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::organisation.organisation');

================
File: src/api/seat-type/content-types/seat-type/schema.json
================
{
  "kind": "collectionType",
  "collectionName": "seat_types",
  "info": {
    "singularName": "seat-type",
    "pluralName": "seat-types",
    "displayName": "SeatType",
    "description": ""
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "name": {
      "type": "string"
    },
    "price": {
      "type": "string"
    },
    "maxNumberOfSeats": {
      "type": "integer"
    },
    "seatsRange": {
      "type": "string"
    },
    "pricePerSeat": {
      "type": "string"
    },
    "storagePrice": {
      "type": "string"
    },
    "maxStorage": {
      "type": "string"
    },
    "maxChannels": {
      "type": "integer"
    },
    "description": {
      "type": "text"
    }
  }
}

================
File: src/api/seat-type/controllers/seat-type.js
================
'use strict';

/**
 * seat-type controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::seat-type.seat-type');

================
File: src/api/seat-type/routes/seat-type.js
================
'use strict';

/**
 * seat-type router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::seat-type.seat-type');

================
File: src/api/seat-type/services/seat-type.js
================
'use strict';

/**
 * seat-type service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::seat-type.seat-type');

================
File: src/api/series/content-types/series/schema.json
================
{
  "kind": "collectionType",
  "collectionName": "series_list",
  "info": {
    "singularName": "series",
    "pluralName": "series-list",
    "displayName": "Series",
    "description": ""
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "name": {
      "type": "string"
    },
    "description": {
      "type": "text"
    },
    "channel": {
      "type": "relation",
      "relation": "manyToOne",
      "target": "api::channel.channel",
      "inversedBy": "series"
    },
    "organisation": {
      "type": "relation",
      "relation": "manyToOne",
      "target": "api::organisation.organisation",
      "inversedBy": "series"
    },
    "users": {
      "type": "relation",
      "relation": "manyToMany",
      "target": "plugin::users-permissions.user",
      "mappedBy": "series"
    }
  }
}

================
File: src/api/series/controllers/series.js
================
'use strict';

/**
 * series controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::series.series');

================
File: src/api/series/routes/series.js
================
'use strict';

/**
 * series router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::series.series');

================
File: src/api/series/services/series.js
================
'use strict';

/**
 * series service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::series.series');

================
File: src/extensions/users-permissions/content-types/user/schema.json
================
{
  "kind": "collectionType",
  "collectionName": "up_users",
  "info": {
    "name": "user",
    "description": "",
    "singularName": "user",
    "pluralName": "users",
    "displayName": "User"
  },
  "options": {
    "draftAndPublish": false
  },
  "attributes": {
    "username": {
      "type": "string",
      "minLength": 3,
      "unique": true,
      "configurable": false,
      "required": true
    },
    "email": {
      "type": "email",
      "minLength": 6,
      "configurable": false,
      "required": true
    },
    "provider": {
      "type": "string",
      "configurable": false
    },
    "password": {
      "type": "password",
      "minLength": 6,
      "configurable": false,
      "private": true,
      "searchable": false
    },
    "resetPasswordToken": {
      "type": "string",
      "configurable": false,
      "private": true,
      "searchable": false
    },
    "confirmationToken": {
      "type": "string",
      "configurable": false,
      "private": true,
      "searchable": false
    },
    "confirmed": {
      "type": "boolean",
      "default": false,
      "configurable": false
    },
    "blocked": {
      "type": "boolean",
      "default": false,
      "configurable": false
    },
    "role": {
      "type": "relation",
      "relation": "manyToOne",
      "target": "plugin::users-permissions.role",
      "inversedBy": "users",
      "configurable": false
    },
    "organisations": {
      "type": "relation",
      "relation": "manyToMany",
      "target": "api::organisation.organisation",
      "mappedBy": "users"
    },
    "firstName": {
      "type": "string"
    },
    "lastName": {
      "type": "string"
    },
    "adminOf": {
      "type": "relation",
      "relation": "manyToMany",
      "target": "api::organisation.organisation",
      "mappedBy": "admins"
    },
    "channels": {
      "type": "relation",
      "relation": "manyToMany",
      "target": "api::channel.channel",
      "inversedBy": "users"
    },
    "series": {
      "type": "relation",
      "relation": "manyToMany",
      "target": "api::series.series",
      "inversedBy": "users"
    }

  }
}

================
File: src/index.js
================
'use strict';

module.exports = {
  /**
   * An asynchronous register function that runs before
   * your application is initialized.
   *
   * This gives you an opportunity to extend code.
   */
  register(/*{ strapi }*/) {},

  /**
   * An asynchronous bootstrap function that runs before
   * your application gets started.
   *
   * This gives you an opportunity to set up your data model,
   * run jobs, or perform some special logic.
   */
  bootstrap(/*{ strapi }*/) {},
};

================
File: types/generated/components.d.ts
================
import type { Schema, Attribute } from '@strapi/strapi';

declare module '@strapi/types' {
  export module Shared {}
}

================
File: types/generated/contentTypes.d.ts
================
import type { Schema, Attribute } from '@strapi/strapi';

export interface AdminPermission extends Schema.CollectionType {
  collectionName: 'admin_permissions';
  info: {
    name: 'Permission';
    description: '';
    singularName: 'permission';
    pluralName: 'permissions';
    displayName: 'Permission';
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    action: Attribute.String &
      Attribute.Required &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    actionParameters: Attribute.JSON & Attribute.DefaultTo<{}>;
    subject: Attribute.String &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    properties: Attribute.JSON & Attribute.DefaultTo<{}>;
    conditions: Attribute.JSON & Attribute.DefaultTo<[]>;
    role: Attribute.Relation<'admin::permission', 'manyToOne', 'admin::role'>;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'admin::permission',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'admin::permission',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface AdminUser extends Schema.CollectionType {
  collectionName: 'admin_users';
  info: {
    name: 'User';
    description: '';
    singularName: 'user';
    pluralName: 'users';
    displayName: 'User';
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    firstname: Attribute.String &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    lastname: Attribute.String &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    username: Attribute.String;
    email: Attribute.Email &
      Attribute.Required &
      Attribute.Private &
      Attribute.Unique &
      Attribute.SetMinMaxLength<{
        minLength: 6;
      }>;
    password: Attribute.Password &
      Attribute.Private &
      Attribute.SetMinMaxLength<{
        minLength: 6;
      }>;
    resetPasswordToken: Attribute.String & Attribute.Private;
    registrationToken: Attribute.String & Attribute.Private;
    isActive: Attribute.Boolean &
      Attribute.Private &
      Attribute.DefaultTo<false>;
    roles: Attribute.Relation<'admin::user', 'manyToMany', 'admin::role'> &
      Attribute.Private;
    blocked: Attribute.Boolean & Attribute.Private & Attribute.DefaultTo<false>;
    preferedLanguage: Attribute.String;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<'admin::user', 'oneToOne', 'admin::user'> &
      Attribute.Private;
    updatedBy: Attribute.Relation<'admin::user', 'oneToOne', 'admin::user'> &
      Attribute.Private;
  };
}

export interface AdminRole extends Schema.CollectionType {
  collectionName: 'admin_roles';
  info: {
    name: 'Role';
    description: '';
    singularName: 'role';
    pluralName: 'roles';
    displayName: 'Role';
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    name: Attribute.String &
      Attribute.Required &
      Attribute.Unique &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    code: Attribute.String &
      Attribute.Required &
      Attribute.Unique &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    description: Attribute.String;
    users: Attribute.Relation<'admin::role', 'manyToMany', 'admin::user'>;
    permissions: Attribute.Relation<
      'admin::role',
      'oneToMany',
      'admin::permission'
    >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<'admin::role', 'oneToOne', 'admin::user'> &
      Attribute.Private;
    updatedBy: Attribute.Relation<'admin::role', 'oneToOne', 'admin::user'> &
      Attribute.Private;
  };
}

export interface AdminApiToken extends Schema.CollectionType {
  collectionName: 'strapi_api_tokens';
  info: {
    name: 'Api Token';
    singularName: 'api-token';
    pluralName: 'api-tokens';
    displayName: 'Api Token';
    description: '';
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    name: Attribute.String &
      Attribute.Required &
      Attribute.Unique &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    description: Attribute.String &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }> &
      Attribute.DefaultTo<''>;
    type: Attribute.Enumeration<['read-only', 'full-access', 'custom']> &
      Attribute.Required &
      Attribute.DefaultTo<'read-only'>;
    accessKey: Attribute.String &
      Attribute.Required &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    lastUsedAt: Attribute.DateTime;
    permissions: Attribute.Relation<
      'admin::api-token',
      'oneToMany',
      'admin::api-token-permission'
    >;
    expiresAt: Attribute.DateTime;
    lifespan: Attribute.BigInteger;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'admin::api-token',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'admin::api-token',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface AdminApiTokenPermission extends Schema.CollectionType {
  collectionName: 'strapi_api_token_permissions';
  info: {
    name: 'API Token Permission';
    description: '';
    singularName: 'api-token-permission';
    pluralName: 'api-token-permissions';
    displayName: 'API Token Permission';
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    action: Attribute.String &
      Attribute.Required &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    token: Attribute.Relation<
      'admin::api-token-permission',
      'manyToOne',
      'admin::api-token'
    >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'admin::api-token-permission',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'admin::api-token-permission',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface AdminTransferToken extends Schema.CollectionType {
  collectionName: 'strapi_transfer_tokens';
  info: {
    name: 'Transfer Token';
    singularName: 'transfer-token';
    pluralName: 'transfer-tokens';
    displayName: 'Transfer Token';
    description: '';
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    name: Attribute.String &
      Attribute.Required &
      Attribute.Unique &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    description: Attribute.String &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }> &
      Attribute.DefaultTo<''>;
    accessKey: Attribute.String &
      Attribute.Required &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    lastUsedAt: Attribute.DateTime;
    permissions: Attribute.Relation<
      'admin::transfer-token',
      'oneToMany',
      'admin::transfer-token-permission'
    >;
    expiresAt: Attribute.DateTime;
    lifespan: Attribute.BigInteger;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'admin::transfer-token',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'admin::transfer-token',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface AdminTransferTokenPermission extends Schema.CollectionType {
  collectionName: 'strapi_transfer_token_permissions';
  info: {
    name: 'Transfer Token Permission';
    description: '';
    singularName: 'transfer-token-permission';
    pluralName: 'transfer-token-permissions';
    displayName: 'Transfer Token Permission';
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    action: Attribute.String &
      Attribute.Required &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    token: Attribute.Relation<
      'admin::transfer-token-permission',
      'manyToOne',
      'admin::transfer-token'
    >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'admin::transfer-token-permission',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'admin::transfer-token-permission',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface PluginUploadFile extends Schema.CollectionType {
  collectionName: 'files';
  info: {
    singularName: 'file';
    pluralName: 'files';
    displayName: 'File';
    description: '';
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    name: Attribute.String & Attribute.Required;
    alternativeText: Attribute.String;
    caption: Attribute.String;
    width: Attribute.Integer;
    height: Attribute.Integer;
    formats: Attribute.JSON;
    hash: Attribute.String & Attribute.Required;
    ext: Attribute.String;
    mime: Attribute.String & Attribute.Required;
    size: Attribute.Decimal & Attribute.Required;
    url: Attribute.String & Attribute.Required;
    previewUrl: Attribute.String;
    provider: Attribute.String & Attribute.Required;
    provider_metadata: Attribute.JSON;
    related: Attribute.Relation<'plugin::upload.file', 'morphToMany'>;
    folder: Attribute.Relation<
      'plugin::upload.file',
      'manyToOne',
      'plugin::upload.folder'
    > &
      Attribute.Private;
    folderPath: Attribute.String &
      Attribute.Required &
      Attribute.Private &
      Attribute.SetMinMax<
        {
          min: 1;
        },
        number
      >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'plugin::upload.file',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'plugin::upload.file',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface PluginUploadFolder extends Schema.CollectionType {
  collectionName: 'upload_folders';
  info: {
    singularName: 'folder';
    pluralName: 'folders';
    displayName: 'Folder';
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    name: Attribute.String &
      Attribute.Required &
      Attribute.SetMinMax<
        {
          min: 1;
        },
        number
      >;
    pathId: Attribute.Integer & Attribute.Required & Attribute.Unique;
    parent: Attribute.Relation<
      'plugin::upload.folder',
      'manyToOne',
      'plugin::upload.folder'
    >;
    children: Attribute.Relation<
      'plugin::upload.folder',
      'oneToMany',
      'plugin::upload.folder'
    >;
    files: Attribute.Relation<
      'plugin::upload.folder',
      'oneToMany',
      'plugin::upload.file'
    >;
    path: Attribute.String &
      Attribute.Required &
      Attribute.SetMinMax<
        {
          min: 1;
        },
        number
      >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'plugin::upload.folder',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'plugin::upload.folder',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface PluginContentReleasesRelease extends Schema.CollectionType {
  collectionName: 'strapi_releases';
  info: {
    singularName: 'release';
    pluralName: 'releases';
    displayName: 'Release';
  };
  options: {
    draftAndPublish: false;
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    name: Attribute.String & Attribute.Required;
    releasedAt: Attribute.DateTime;
    scheduledAt: Attribute.DateTime;
    timezone: Attribute.String;
    status: Attribute.Enumeration<
      ['ready', 'blocked', 'failed', 'done', 'empty']
    > &
      Attribute.Required;
    actions: Attribute.Relation<
      'plugin::content-releases.release',
      'oneToMany',
      'plugin::content-releases.release-action'
    >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'plugin::content-releases.release',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'plugin::content-releases.release',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface PluginContentReleasesReleaseAction
  extends Schema.CollectionType {
  collectionName: 'strapi_release_actions';
  info: {
    singularName: 'release-action';
    pluralName: 'release-actions';
    displayName: 'Release Action';
  };
  options: {
    draftAndPublish: false;
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    type: Attribute.Enumeration<['publish', 'unpublish']> & Attribute.Required;
    entry: Attribute.Relation<
      'plugin::content-releases.release-action',
      'morphToOne'
    >;
    contentType: Attribute.String & Attribute.Required;
    locale: Attribute.String;
    release: Attribute.Relation<
      'plugin::content-releases.release-action',
      'manyToOne',
      'plugin::content-releases.release'
    >;
    isEntryValid: Attribute.Boolean;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'plugin::content-releases.release-action',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'plugin::content-releases.release-action',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface PluginI18NLocale extends Schema.CollectionType {
  collectionName: 'i18n_locale';
  info: {
    singularName: 'locale';
    pluralName: 'locales';
    collectionName: 'locales';
    displayName: 'Locale';
    description: '';
  };
  options: {
    draftAndPublish: false;
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    name: Attribute.String &
      Attribute.SetMinMax<
        {
          min: 1;
          max: 50;
        },
        number
      >;
    code: Attribute.String & Attribute.Unique;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'plugin::i18n.locale',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'plugin::i18n.locale',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface PluginUsersPermissionsPermission
  extends Schema.CollectionType {
  collectionName: 'up_permissions';
  info: {
    name: 'permission';
    description: '';
    singularName: 'permission';
    pluralName: 'permissions';
    displayName: 'Permission';
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    action: Attribute.String & Attribute.Required;
    role: Attribute.Relation<
      'plugin::users-permissions.permission',
      'manyToOne',
      'plugin::users-permissions.role'
    >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'plugin::users-permissions.permission',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'plugin::users-permissions.permission',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface PluginUsersPermissionsRole extends Schema.CollectionType {
  collectionName: 'up_roles';
  info: {
    name: 'role';
    description: '';
    singularName: 'role';
    pluralName: 'roles';
    displayName: 'Role';
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    name: Attribute.String &
      Attribute.Required &
      Attribute.SetMinMaxLength<{
        minLength: 3;
      }>;
    description: Attribute.String;
    type: Attribute.String & Attribute.Unique;
    permissions: Attribute.Relation<
      'plugin::users-permissions.role',
      'oneToMany',
      'plugin::users-permissions.permission'
    >;
    users: Attribute.Relation<
      'plugin::users-permissions.role',
      'oneToMany',
      'plugin::users-permissions.user'
    >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'plugin::users-permissions.role',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'plugin::users-permissions.role',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface PluginUsersPermissionsUser extends Schema.CollectionType {
  collectionName: 'up_users';
  info: {
    name: 'user';
    description: '';
    singularName: 'user';
    pluralName: 'users';
    displayName: 'User';
  };
  options: {
    draftAndPublish: false;
  };
  attributes: {
    username: Attribute.String &
      Attribute.Required &
      Attribute.Unique &
      Attribute.SetMinMaxLength<{
        minLength: 3;
      }>;
    email: Attribute.Email &
      Attribute.Required &
      Attribute.SetMinMaxLength<{
        minLength: 6;
      }>;
    provider: Attribute.String;
    password: Attribute.Password &
      Attribute.Private &
      Attribute.SetMinMaxLength<{
        minLength: 6;
      }>;
    resetPasswordToken: Attribute.String & Attribute.Private;
    confirmationToken: Attribute.String & Attribute.Private;
    confirmed: Attribute.Boolean & Attribute.DefaultTo<false>;
    blocked: Attribute.Boolean & Attribute.DefaultTo<false>;
    role: Attribute.Relation<
      'plugin::users-permissions.user',
      'manyToOne',
      'plugin::users-permissions.role'
    >;
    organisations: Attribute.Relation<
      'plugin::users-permissions.user',
      'manyToMany',
      'api::organisation.organisation'
    >;
    firstName: Attribute.String;
    lastName: Attribute.String;
    adminOf: Attribute.Relation<
      'plugin::users-permissions.user',
      'manyToMany',
      'api::organisation.organisation'
    >;
    channels: Attribute.Relation<
      'plugin::users-permissions.user',
      'manyToMany',
      'api::channel.channel'
    >;
    series: Attribute.Relation<
      'plugin::users-permissions.user',
      'manyToMany',
      'api::series.series'
    >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'plugin::users-permissions.user',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'plugin::users-permissions.user',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface ApiChannelChannel extends Schema.CollectionType {
  collectionName: 'channels';
  info: {
    singularName: 'channel';
    pluralName: 'channels';
    displayName: 'Channel';
    description: '';
  };
  options: {
    draftAndPublish: true;
  };
  pluginOptions: {
    lifecycles: {
      enabled: true;
    };
  };
  attributes: {
    name: Attribute.String;
    description: Attribute.Text;
    organisation: Attribute.Relation<
      'api::channel.channel',
      'manyToOne',
      'api::organisation.organisation'
    >;
    users: Attribute.Relation<
      'api::channel.channel',
      'oneToMany',
      'plugin::users-permissions.user'
    >;
    invitations: Attribute.Relation<
      'api::channel.channel',
      'oneToMany',
      'api::channel-invitation.channel-invitation'
    >;
    isInternal: Attribute.Boolean & Attribute.DefaultTo<false>;
    series: Attribute.Relation<
      'api::channel.channel',
      'oneToMany',
      'api::series.series'
    >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    publishedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'api::channel.channel',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'api::channel.channel',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface ApiChannelInvitationChannelInvitation
  extends Schema.CollectionType {
  collectionName: 'channel_invitations';
  info: {
    singularName: 'channel-invitation';
    pluralName: 'channel-invitations';
    displayName: 'Channel Invitation';
  };
  options: {
    draftAndPublish: false;
  };
  attributes: {
    email: Attribute.Email & Attribute.Required;
    channel: Attribute.Relation<
      'api::channel-invitation.channel-invitation',
      'manyToOne',
      'api::channel.channel'
    >;
    status: Attribute.Enumeration<['pending', 'accepted', 'rejected']> &
      Attribute.DefaultTo<'pending'>;
    token: Attribute.String & Attribute.Unique;
    invitedBy: Attribute.Relation<
      'api::channel-invitation.channel-invitation',
      'manyToOne',
      'plugin::users-permissions.user'
    >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'api::channel-invitation.channel-invitation',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'api::channel-invitation.channel-invitation',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface ApiCountryCountry extends Schema.CollectionType {
  collectionName: 'countries';
  info: {
    singularName: 'country';
    pluralName: 'countries';
    displayName: 'Country';
  };
  options: {
    draftAndPublish: true;
  };
  attributes: {
    name: Attribute.String;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    publishedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'api::country.country',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'api::country.country',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface ApiInvitationInvitation extends Schema.CollectionType {
  collectionName: 'invitations';
  info: {
    singularName: 'invitation';
    pluralName: 'invitations';
    displayName: 'Invitation';
    description: 'Invitations for organizations, channels, and series';
  };
  options: {
    draftAndPublish: false;
  };
  attributes: {
    email: Attribute.Email & Attribute.Required;
    status: Attribute.Enumeration<['pending', 'accepted', 'rejected']> &
      Attribute.DefaultTo<'pending'>;
    token: Attribute.String & Attribute.Unique;
    invitedBy: Attribute.Relation<
      'api::invitation.invitation',
      'manyToOne',
      'plugin::users-permissions.user'
    >;
    organisation: Attribute.Relation<
      'api::invitation.invitation',
      'manyToOne',
      'api::organisation.organisation'
    >;
    channel: Attribute.Relation<
      'api::invitation.invitation',
      'manyToOne',
      'api::channel.channel'
    >;
    series: Attribute.Relation<
      'api::invitation.invitation',
      'manyToOne',
      'api::series.series'
    >;
    invitationType: Attribute.Enumeration<
      ['organisation', 'channel', 'series']
    > &
      Attribute.Required;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'api::invitation.invitation',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'api::invitation.invitation',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface ApiOrganisationOrganisation extends Schema.CollectionType {
  collectionName: 'organisations';
  info: {
    singularName: 'organisation';
    pluralName: 'organisations';
    displayName: 'Organisation';
    description: '';
  };
  options: {
    draftAndPublish: true;
  };
  attributes: {
    name: Attribute.String;
    description: Attribute.Text;
    size: Attribute.String;
    location: Attribute.String;
    users: Attribute.Relation<
      'api::organisation.organisation',
      'manyToMany',
      'plugin::users-permissions.user'
    >;
    seat_type: Attribute.Relation<
      'api::organisation.organisation',
      'oneToOne',
      'api::seat-type.seat-type'
    >;
    country: Attribute.String;
    admins: Attribute.Relation<
      'api::organisation.organisation',
      'manyToMany',
      'plugin::users-permissions.user'
    >;
    invitations: Attribute.Relation<
      'api::organisation.organisation',
      'oneToMany',
      'api::invitation.invitation'
    >;
    channels: Attribute.Relation<
      'api::organisation.organisation',
      'oneToMany',
      'api::channel.channel'
    >;
    series: Attribute.Relation<
      'api::organisation.organisation',
      'oneToMany',
      'api::series.series'
    >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    publishedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'api::organisation.organisation',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'api::organisation.organisation',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface ApiSeatTypeSeatType extends Schema.CollectionType {
  collectionName: 'seat_types';
  info: {
    singularName: 'seat-type';
    pluralName: 'seat-types';
    displayName: 'SeatType';
    description: '';
  };
  options: {
    draftAndPublish: true;
  };
  attributes: {
    name: Attribute.String;
    price: Attribute.String;
    maxNumberOfSeats: Attribute.Integer;
    seatsRange: Attribute.String;
    pricePerSeat: Attribute.String;
    storagePrice: Attribute.String;
    maxStorage: Attribute.String;
    maxChannels: Attribute.Integer;
    description: Attribute.Text;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    publishedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'api::seat-type.seat-type',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'api::seat-type.seat-type',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface ApiSeriesSeries extends Schema.CollectionType {
  collectionName: 'series_list';
  info: {
    singularName: 'series';
    pluralName: 'series-list';
    displayName: 'Series';
    description: '';
  };
  options: {
    draftAndPublish: true;
  };
  attributes: {
    name: Attribute.String;
    description: Attribute.Text;
    channel: Attribute.Relation<
      'api::series.series',
      'manyToOne',
      'api::channel.channel'
    >;
    organisation: Attribute.Relation<
      'api::series.series',
      'manyToOne',
      'api::organisation.organisation'
    >;
    users: Attribute.Relation<
      'api::series.series',
      'manyToMany',
      'plugin::users-permissions.user'
    >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    publishedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'api::series.series',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'api::series.series',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

declare module '@strapi/types' {
  export module Shared {
    export interface ContentTypes {
      'admin::permission': AdminPermission;
      'admin::user': AdminUser;
      'admin::role': AdminRole;
      'admin::api-token': AdminApiToken;
      'admin::api-token-permission': AdminApiTokenPermission;
      'admin::transfer-token': AdminTransferToken;
      'admin::transfer-token-permission': AdminTransferTokenPermission;
      'plugin::upload.file': PluginUploadFile;
      'plugin::upload.folder': PluginUploadFolder;
      'plugin::content-releases.release': PluginContentReleasesRelease;
      'plugin::content-releases.release-action': PluginContentReleasesReleaseAction;
      'plugin::i18n.locale': PluginI18NLocale;
      'plugin::users-permissions.permission': PluginUsersPermissionsPermission;
      'plugin::users-permissions.role': PluginUsersPermissionsRole;
      'plugin::users-permissions.user': PluginUsersPermissionsUser;
      'api::channel.channel': ApiChannelChannel;
      'api::channel-invitation.channel-invitation': ApiChannelInvitationChannelInvitation;
      'api::country.country': ApiCountryCountry;
      'api::invitation.invitation': ApiInvitationInvitation;
      'api::organisation.organisation': ApiOrganisationOrganisation;
      'api::seat-type.seat-type': ApiSeatTypeSeatType;
      'api::series.series': ApiSeriesSeries;
    }
  }
}

================
File: .editorconfig
================
root = true

[*]
indent_style = space
indent_size = 2
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[{package.json,*.yml}]
indent_style = space
indent_size = 2

[*.md]
trim_trailing_whitespace = false

================
File: .env.example
================
HOST=0.0.0.0
PORT=1337
APP_KEYS="toBeModified1,toBeModified2"
API_TOKEN_SALT=tobemodified
ADMIN_JWT_SECRET=tobemodified
TRANSFER_TOKEN_SALT=tobemodified
JWT_SECRET=tobemodified

================
File: .eslintignore
================
.cache
build
**/node_modules/**

================
File: .eslintrc
================
{
  "parser": "babel-eslint",
  "extends": "eslint:recommended",
  "env": {
    "commonjs": true,
    "es6": true,
    "node": true,
    "browser": false
  },
  "parserOptions": {
    "ecmaFeatures": {
      "experimentalObjectRestSpread": true,
      "jsx": false
    },
    "sourceType": "module"
  },
  "globals": {
    "strapi": true
  },
  "rules": {
    "indent": ["error", 2, { "SwitchCase": 1 }],
    "linebreak-style": ["error", "unix"],
    "no-console": 0,
    "quotes": ["error", "single"],
    "semi": ["error", "always"]
  }
}

================
File: .gitignore
================
############################
# OS X
############################

.DS_Store
.AppleDouble
.LSOverride
Icon
.Spotlight-V100
.Trashes
._*


############################
# Linux
############################

*~


############################
# Windows
############################

Thumbs.db
ehthumbs.db
Desktop.ini
$RECYCLE.BIN/
*.cab
*.msi
*.msm
*.msp


############################
# Packages
############################

*.7z
*.csv
*.dat
*.dmg
*.gz
*.iso
*.jar
*.rar
*.tar
*.zip
*.com
*.class
*.dll
*.exe
*.o
*.seed
*.so
*.swo
*.swp
*.swn
*.swm
*.out
*.pid


############################
# Logs and databases
############################

.tmp
*.log
*.sql
*.sqlite
*.sqlite3


############################
# Misc.
############################

*#
ssl
.idea
nbproject
public/uploads/*
!public/uploads/.gitkeep

############################
# Node.js
############################

lib-cov
lcov.info
pids
logs
results
node_modules
.node_history

############################
# Tests
############################

coverage

############################
# Strapi
############################

.env
license.txt
exports
.strapi
dist
build
.strapi-updater.json

================
File: docker-compose.yml
================
version: '3'

services:
  strapi:
    image: ghcr.io/${GITHUB_REPOSITORY}:latest
    container_name: orchard-strapi
    restart: unless-stopped
    environment:
      - NODE_ENV=production
      - DATABASE_CLIENT=${DATABASE_CLIENT}
      - DATABASE_HOST=${DATABASE_HOST}
      - DATABASE_PORT=${DATABASE_PORT}
      - DATABASE_NAME=${DATABASE_NAME}
      - DATABASE_USERNAME=${DATABASE_USERNAME}
      - DATABASE_PASSWORD=${DATABASE_PASSWORD}
      - DATABASE_SSL=${DATABASE_SSL}
      - JWT_SECRET=${JWT_SECRET}
      - ADMIN_JWT_SECRET=${ADMIN_JWT_SECRET}
      - APP_KEYS=${APP_KEYS}
      - API_TOKEN_SALT=${API_TOKEN_SALT}
      - SENDGRID_API_KEY=${SENDGRID_API_KEY}
      - STRAPI_ADMIN_URL=${STRAPI_ADMIN_URL}
      - STRAPI_ADMIN_BACKEND_URL=${STRAPI_ADMIN_BACKEND_URL}
      - PUBLIC_URL=${PUBLIC_URL}
      - ADMIN_URL=${ADMIN_URL}
      - ADMIN_PATH=${ADMIN_PATH}
      - FRONTEND_URL=${FRONTEND_URL}
    volumes:
      - ./config:/usr/src/app/config
      - ./src:/usr/src/app/src
      - ./.env:/usr/src/app/.env
      - ./public/uploads:/usr/src/app/public/uploads
    networks:
      - proxy
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.orchard-strapi.rule=Host(`orchard-backend.deant.work`)"
      - "traefik.http.routers.orchard-strapi.entrypoints=websecure"
      - "traefik.http.routers.orchard-strapi.tls.certresolver=letsencrypt"
      - "traefik.http.services.orchard-strapi.loadbalancer.server.port=1337"

volumes:
  orchard-data:

networks:
  proxy:
    external: true

================
File: Dockerfile
================
# Build stage
FROM node:18-alpine as builder

# Install dependencies for building
RUN apk add --no-cache build-base gcc autoconf automake zlib-dev libpng-dev nasm bash vips-dev

# Set working directory
WORKDIR /app

# Copy package.json and package-lock.json
COPY package*.json ./

# Install dependencies
RUN npm ci

# Copy source files
COPY . .

# Build the Strapi application
RUN npm run build

# Production stage
FROM node:18-alpine

# Install runtime dependencies
RUN apk add --no-cache vips-dev

# Set working directory
WORKDIR /app

# Copy built assets from the builder stage
COPY --from=builder /app ./

# Set NODE_ENV to production
ENV NODE_ENV=production

# Expose the Strapi port
EXPOSE 1337

# Start Strapi
CMD ["npm", "run", "start"]

================
File: jsconfig.json
================
{
  "compilerOptions": {
    "moduleResolution": "nodenext",
    "target": "ES2021",
    "checkJs": true,
    "allowJs": true
  }
}

================
File: package.json
================
{
  "name": "orchard",
  "private": true,
  "version": "0.1.0",
  "description": "A Strapi application",
  "scripts": {
    "develop": "strapi develop",
    "start": "strapi start",
    "build": "strapi build",
    "strapi": "strapi"
  },
  "dependencies": {
    "@strapi/plugin-cloud": "4.24.4",
    "@strapi/plugin-i18n": "4.24.4",
    "@strapi/plugin-users-permissions": "4.24.4",
    "@strapi/provider-email-sendgrid": "^4.25.8",
    "@strapi/strapi": "4.24.4",
    "@strapi/utils": "^4.25.10",
    "better-sqlite3": "8.6.0",
    "pg": "^8.12.0",
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "react-router-dom": "5.3.4",
    "strapi-plugin-netlify-deployments": "^2.0.2",
    "styled-components": "5.3.3"
  },
  "author": {
    "name": "A Strapi developer"
  },
  "strapi": {
    "uuid": "70fb6dba-c696-4fbf-a45c-2f3e8a216631"
  },
  "engines": {
    "node": ">=18.0.0 <=20.x.x",
    "npm": ">=6.0.0"
  },
  "license": "MIT"
}

================
File: README.md
================
# Orchard Backend

Orchard Backend is a Strapi-based application that serves as the backend for the Orchard.works platform. It provides APIs for managing organizations, channels, users, and invitations.

## 🚀 Features

- User authentication and authorization
- Organization management
- Channel creation and management
- User invitations for organizations and channels
- Seat type management
- Email notifications using SendGrid

## 🛠 Tech Stack

- [Strapi](https://strapi.io/) - Headless CMS
- [Node.js](https://nodejs.org/)
- [PostgreSQL](https://www.postgresql.org/) - Database
- [Docker](https://www.docker.com/) - Containerization
- [GitHub Actions](https://github.com/features/actions) - CI/CD

## 🏗 Project Structure

The project follows the standard Strapi structure with some custom configurations:

- `/config`: Configuration files for the Strapi application
- `/src`: Source code for the application
  - `/api`: API definitions for various content types
  - `/extensions`: Custom extensions for Strapi plugins
- `/public`: Public assets
- `/.github/workflows`: GitHub Actions workflow for CI/CD

## 🚦 Getting Started

### Prerequisites

- Node.js (version 18.x or 20.x)
- npm or yarn
- PostgreSQL database

### Local Development

1. Clone the repository:
   ```
   git clone <repository-url>
   cd orchard-backend
   ```

2. Install dependencies:
   ```
   npm install
   ```

3. Copy the `.env.example` file to `.env` and update the environment variables:
   ```
   cp .env.example .env
   ```

4. Start the development server:
   ```
   npm run develop
   ```

The Strapi admin panel will be available at `http://localhost:1337/admin`.

### Docker Deployment

The project includes a `Dockerfile` and `docker-compose.yml` for easy deployment:

1. Build the Docker image:
   ```
   docker build -t orchard-backend .
   ```

2. Start the container:
   ```
   docker-compose up -d
   ```

## 📚 API Documentation

Once the server is running, you can access the API documentation at:

```
http://localhost:1337/documentation
```

This provides an interactive Swagger UI for exploring and testing the APIs.

## 🔐 Authentication

The project uses Strapi's built-in authentication system. To authenticate:

1. Register a new user or log in with existing credentials
2. Use the provided JWT token in the `Authorization` header for subsequent requests

## 🔧 Configuration

Key configuration files:

- `config/server.js`: Server configuration
- `config/database.js`: Database configuration
- `config/plugins.js`: Plugin configurations (e.g., email provider)

## 📨 Email Notifications

The project uses SendGrid for sending email notifications. Configure your SendGrid API key in the `.env` file:

```
SENDGRID_API_KEY=your_sendgrid_api_key
```

## 🚢 Deployment

The project includes a GitHub Actions workflow for automated deployment:

1. Push changes to the `main` branch
2. The workflow builds a Docker image and pushes it to GitHub Container Registry
3. The image is then deployed to the specified server

Ensure all required secrets are set in your GitHub repository settings.

## 🤝 Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## 📄 License

This project is licensed under the MIT License.
