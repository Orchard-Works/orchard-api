================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-09-16T08:20:26.710Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
config/
  admin.js
  api.js
  database.js
  middlewares.js
  plugins.js
  server.js
public/
  robots.txt
src/
  admin/
    app.example.js
    webpack.config.example.js
  api/
    channel/
      content-types/
        channel/
          schema.json
      controllers/
        channel.js
      routes/
        channel.js
      services/
        channel.js
    channel-invitation/
      content-types/
        channel-invitation/
          schema.json
      controllers/
        channel-invitation.js
      routes/
        channel-invitation.js
      services/
        channel-invitation.js
    country/
      content-types/
        country/
          schema.json
      controllers/
        country.js
      routes/
        country.js
      services/
        country.js
    invitation/
      content-types/
        invitation/
          schema.json
      controllers/
        invitation.js
      routes/
        invitation.js
      services/
        invitation.js
    organisation/
      content-types/
        organisation/
          schema.json
      controllers/
        organisation.js
      routes/
        organisation.js
      services/
        organisation.js
    seat-type/
      content-types/
        seat-type/
          schema.json
      controllers/
        seat-type.js
      routes/
        seat-type.js
      services/
        seat-type.js
  extensions/
    users-permissions/
      content-types/
        user/
          schema.json
  index.js
types/
  generated/
    components.d.ts
    contentTypes.d.ts
.editorconfig
.env.example
.eslintignore
.eslintrc
.gitignore
jsconfig.json
package.json
README.md

================================================================
Repository Files
================================================================

================
File: config/admin.js
================
module.exports = ({ env }) => ({
  auth: {
    secret: "tobemodified",
  },
  apiToken: {
    salt: "tobemodified",
  },
  transfer: {
    token: {
      salt: "tobemodified",
    },
  },
  flags: {
    nps: true,
    promoteEE: true,
  },
});

================
File: config/api.js
================
module.exports = {
  rest: {
    defaultLimit: 25,
    maxLimit: 100,
    withCount: true,
  },
};

================
File: config/database.js
================
const path = require('path');

module.exports = ({ env }) => {
  const client = 'postgres';

  const connections = {
    postgres: {
      connection: {
        host: env('DATABASE_HOST', 'aws-0-eu-central-1.pooler.supabase.com'),
        port: env.int('DATABASE_PORT', 6543),
        database: env('DATABASE_NAME', 'postgres'),
        user: env('DATABASE_USERNAME', 'postgres.qpiztsshbfbynliwozjs'),
        password: env('DATABASE_PASSWORD', 'SkGO5Ku6bF70b7S7'),
        ssl: env.bool('DATABASE_SSL', false),
        schema: env('DATABASE_SCHEMA', 'public'),
      },
      pool: { min: env.int('DATABASE_POOL_MIN', 2), max: env.int('DATABASE_POOL_MAX', 10) },
    },
  };

  return {
    connection: {
      client,
      ...connections[client],
      acquireConnectionTimeout: env.int('DATABASE_CONNECTION_TIMEOUT', 60000),
    },
  };
};

================
File: config/middlewares.js
================
module.exports = [
  'strapi::logger',
  'strapi::errors',
  'strapi::security',
  'strapi::cors',
  'strapi::poweredBy',
  'strapi::query',
  'strapi::body',
  'strapi::session',
  'strapi::favicon',
  'strapi::public',
];

================
File: config/plugins.js
================
module.exports = ({env}) => ({
  "netlify-deployments": {
    enabled: true,
    config: {
      accessToken: env("NETLIFY_ACCESS_TOKEN"),

      sites:[
        {
          name: 'orchard-works-api',
          id: env("NETLIFY_SITE_ID"),
          buildHook: env("NETLIFY_BUILD_HOOK"),
        }
      ]
    },
  },
  email: {
    config: {
      provider: "sendgrid",
      providerOptions: {
        apiKey: env("SENDGRID_API_KEY"),
      },
      settings: {
        defaultFrom: "dean@harvestanimation.com",
        defaultReplyTo: "dean@harvestanimation.com",
      },
    },
  },
});

================
File: config/server.js
================
module.exports = ({ env }) => ({
  host: env('HOST', '0.0.0.0'),
  port: env.int('PORT', 1337),
  app: {
    keys: env.array('APP_KEYS'),
  },
  webhooks: {
    populateRelations: env.bool('WEBHOOKS_POPULATE_RELATIONS', false),
  },
});

================
File: public/robots.txt
================
# To prevent search engines from seeing the site altogether, uncomment the next two lines:
# User-Agent: *
# Disallow: /

================
File: src/admin/app.example.js
================
const config = {
  locales: [
    // 'ar',
    // 'fr',
    // 'cs',
    // 'de',
    // 'dk',
    // 'es',
    // 'he',
    // 'id',
    // 'it',
    // 'ja',
    // 'ko',
    // 'ms',
    // 'nl',
    // 'no',
    // 'pl',
    // 'pt-BR',
    // 'pt',
    // 'ru',
    // 'sk',
    // 'sv',
    // 'th',
    // 'tr',
    // 'uk',
    // 'vi',
    // 'zh-Hans',
    // 'zh',
  ],
};

const bootstrap = (app) => {
  console.log(app);
};

export default {
  config,
  bootstrap,
};

================
File: src/admin/webpack.config.example.js
================
'use strict';

/* eslint-disable no-unused-vars */
module.exports = (config, webpack) => {
  // Note: we provide webpack above so you should not `require` it
  // Perform customizations to webpack config
  // Important: return the modified config
  return config;
};

================
File: src/api/channel/content-types/channel/schema.json
================
{
  "kind": "collectionType",
  "collectionName": "channels",
  "info": {
    "singularName": "channel",
    "pluralName": "channels",
    "displayName": "Channel",
    "description": ""
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "name": {
      "type": "string"
    },
    "description": {
      "type": "text"
    },
    "organisation": {
      "type": "relation",
      "relation": "manyToOne",
      "target": "api::organisation.organisation",
      "inversedBy": "channels"
    },
    "users": {
      "type": "relation",
      "relation": "oneToMany",
      "target": "plugin::users-permissions.user"
    },
    "invitations": {
      "type": "relation",
      "relation": "oneToMany",
      "target": "api::channel-invitation.channel-invitation",
      "mappedBy": "channel"
    },
    "isInternal": {
      "type": "boolean",
      "default": false
    }
  }
}

================
File: src/api/channel/controllers/channel.js
================
'use strict';

/**
 * channel controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::channel.channel', ({ strapi }) => ({
  // Find all channels
  async find(ctx) {
    try {
      const channels = await strapi.entityService.findMany('api::channel.channel', {
        ...ctx.query,
      });
      return channels;
    } catch (err) {
      ctx.throw(500, err);
    }
  },

  // Find a specific channel
  async findOne(ctx) {
    try {
      const { id } = ctx.params;
      const channel = await strapi.entityService.findOne('api::channel.channel', id, {
        ...ctx.query,
      });
      if (!channel) return ctx.notFound();
      return channel;
    } catch (err) {
      ctx.throw(500, err);
    }
  },

  // Create a new channel
  async create(ctx) {
    try {
      const { name, description, organisationId, isInternal, invitedEmails } = ctx.request.body;

      if (!name || !organisationId) {
        return ctx.badRequest('Name and organisation ID are required');
      }

      const channel = await strapi.entityService.create('api::channel.channel', {
        data: {
          name,
          description,
          organisation: organisationId,
          isInternal: isInternal || false,
          publishedAt: new Date(),
        },
      });

      // Handle invitations logic here (if needed)
      if (invitedEmails && Array.isArray(invitedEmails)) {
        // Implement invitation logic
      }

      return channel;
    } catch (err) {
      ctx.throw(500, err);
    }
  },

  // Update a channel
  async update(ctx) {
    try {
      const { id } = ctx.params;
      const updateData = ctx.request.body;
      const updatedChannel = await strapi.entityService.update('api::channel.channel', id, {
        data: updateData,
      });
      return updatedChannel;
    } catch (err) {
      ctx.throw(500, err);
    }
  },

  // Delete a channel
  async delete(ctx) {
    try {
      const { id } = ctx.params;
      const deletedChannel = await strapi.entityService.delete('api::channel.channel', id);
      return deletedChannel;
    } catch (err) {
      ctx.throw(500, err);
    }
  },

  // Accept invitation to a channel
  async acceptInvitation(ctx) {
    try {
      const { token } = ctx.params;
      const { user } = ctx.state;

      if (!user) {
        return ctx.unauthorized('You must be logged in to accept an invitation');
      }

      // Implement your invitation acceptance logic here
      // This is a placeholder implementation
      const invitation = await strapi.entityService.findMany('api::channel-invitation.channel-invitation', {
        filters: { token },
        populate: ['channel'],
      });

      if (!invitation || invitation.length === 0) {
        return ctx.notFound('Invitation not found');
      }

      const channelInvitation = invitation[0];

      if (channelInvitation.status !== 'pending') {
        return ctx.badRequest('This invitation has already been processed');
      }

      // Update invitation status
      await strapi.entityService.update('api::channel-invitation.channel-invitation', channelInvitation.id, {
        data: { status: 'accepted' },
      });

      // Add user to channel
      await strapi.entityService.update('api::channel.channel', channelInvitation.channel.id, {
        data: { users: { connect: [user.id] } },
      });

      return { message: 'Invitation accepted successfully' };
    } catch (err) {
      ctx.throw(500, err);
    }
  },
}));

================
File: src/api/channel/routes/channel.js
================
'use strict';

module.exports = {
  routes: [
    {
      method: 'GET',
      path: '/channels',
      handler: 'channel.find',
      config: {
        policies: [],
        middlewares: [],
      },
    },
    {
      method: 'GET',
      path: '/channels/:id',
      handler: 'channel.findOne',
      config: {
        policies: [],
        middlewares: [],
      },
    },
    {
      method: 'POST',
      path: '/channels',
      handler: 'channel.create',
      config: {
        policies: [],
        middlewares: [],
      },
    },
    {
      method: 'PUT',
      path: '/channels/:id',
      handler: 'channel.update',
      config: {
        policies: [],
        middlewares: [],
      },
    },
    {
      method: 'DELETE',
      path: '/channels/:id',
      handler: 'channel.delete',
      config: {
        policies: [],
        middlewares: [],
      },
    },

    {
      method: 'POST',
      path: '/channels/accept-invitation/:token',
      handler: 'channel.acceptInvitation',
      config: {
        policies: [],
        middlewares: [],
      },
    },
  ],
};

================
File: src/api/channel/services/channel.js
================
'use strict';

/**
 * channel service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::channel.channel');

================
File: src/api/channel-invitation/content-types/channel-invitation/schema.json
================
{
  "kind": "collectionType",
  "collectionName": "channel_invitations",
  "info": {
    "singularName": "channel-invitation",
    "pluralName": "channel-invitations",
    "displayName": "Channel Invitation"
  },
  "options": {
    "draftAndPublish": false
  },
  "attributes": {
    "email": {
      "type": "email",
      "required": true
    },
    "channel": {
      "type": "relation",
      "relation": "manyToOne",
      "target": "api::channel.channel",
      "inversedBy": "invitations"
    },
    "status": {
      "type": "enumeration",
      "enum": [
        "pending",
        "accepted",
        "rejected"
      ],
      "default": "pending"
    },
    "token": {
      "type": "string",
      "unique": true
    },
    "invitedBy": {
      "type": "relation",
      "relation": "manyToOne",
      "target": "plugin::users-permissions.user"
    }
  }
}

================
File: src/api/channel-invitation/controllers/channel-invitation.js
================
'use strict';

/**
 * channel-invitation controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::channel-invitation.channel-invitation');

================
File: src/api/channel-invitation/routes/channel-invitation.js
================
'use strict';

/**
 * channel-invitation router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::channel-invitation.channel-invitation');

================
File: src/api/channel-invitation/services/channel-invitation.js
================
'use strict';

/**
 * channel-invitation service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::channel-invitation.channel-invitation');

================
File: src/api/country/content-types/country/schema.json
================
{
  "kind": "collectionType",
  "collectionName": "countries",
  "info": {
    "singularName": "country",
    "pluralName": "countries",
    "displayName": "Country"
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "name": {
      "type": "string"
    }
  }
}

================
File: src/api/country/controllers/country.js
================
'use strict';

/**
 * country controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::country.country');

================
File: src/api/country/routes/country.js
================
'use strict';

/**
 * country router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::country.country');

================
File: src/api/country/services/country.js
================
'use strict';

/**
 * country service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::country.country');

================
File: src/api/invitation/content-types/invitation/schema.json
================
{
  "kind": "collectionType",
  "collectionName": "invitations",
  "info": {
    "singularName": "invitation",
    "pluralName": "invitations",
    "displayName": "Invitation"
  },
  "options": {
    "draftAndPublish": false
  },
  "attributes": {
    "email": {
      "type": "email",
      "required": true
    },
    "organisation": {
      "type": "relation",
      "relation": "manyToOne",
      "target": "api::organisation.organisation",
      "inversedBy": "invitations"
    },
    "invitedBy": {
      "type": "relation",
      "relation": "manyToOne",
      "target": "plugin::users-permissions.user"
    },
    "status": {
      "type": "enumeration",
      "enum": [
        "pending",
        "accepted",
        "rejected"
      ],
      "default": "pending"
    },
    "token": {
      "type": "string",
      "unique": true
    }
  }
}

================
File: src/api/invitation/controllers/invitation.js
================
'use strict';

const { sanitizeEntity } = require('@strapi/utils');
const crypto = require('crypto');

module.exports = {

  async find(ctx) {
    const user = ctx.state.user;

    if (!user) {
      return ctx.unauthorized('You must be logged in to view invitations');
    }

    let invitations;
    if (user.role.name === 'Admin') {
      // If user is admin, fetch all invitations
      invitations = await strapi.entityService.findMany('api::invitation.invitation', {
        populate: ['organization', 'invitedBy'],
      });
    } else {
      // If user is not admin, fetch only invitations for organizations they manage
      const userOrganizations = await strapi.entityService.findMany('api::organisation.organisation', {
        filters: {
          admins: {
            id: user.id,
          },
        },
      });

      const organizationIds = userOrganizations.map(org => org.id);

      invitations = await strapi.entityService.findMany('api::invitation.invitation', {
        filters: {
          organization: {
            id: {
              $in: organizationIds,
            },
          },
        },
        populate: ['organization', 'invitedBy'],
      });
    }

    return invitations.map(invitation => sanitizeEntity(invitation, { model: strapi.contentTypes['api::invitation.invitation'] }));
  },



  async create(ctx) {
    const { email, organizationId } = ctx.request.body;
    const user = ctx.state.user;

    if (!user) {
      return ctx.unauthorized('You must be logged in to invite users');
    }

    const organization = await strapi.services.organisation.findOne({ id: organizationId });
    if (!organization) {
      return ctx.notFound('Organization not found');
    }

    // Check if the user has permission to invite to this organization
    // This would depend on your permission structure

    const token = crypto.randomBytes(32).toString('hex');

    const invitation = await strapi.services.invitation.create({
      email,
      organization: organizationId,
      invitedBy: user.id,
      token,
      status: 'pending'
    });

    // Send invitation email
    await strapi.plugins['email'].services.email.send({
      to: email,
      subject: 'Invitation to join an organization on Orchard.works',
      text: `You've been invited to join ${organization.name} on Orchard.works. Click here to accept: ${process.env.FRONTEND_URL}/invite/${token}`,
      html: `<p>You've been invited to join ${organization.name} on Orchard.works.</p><p><a href="${process.env.FRONTEND_URL}/invite/${token}">Click here to accept</a></p>`
    });

    return sanitizeEntity(invitation, { model: strapi.models.invitation });
  },

  async accept(ctx) {
    const { token } = ctx.params;
    const user = ctx.state.user;

    if (!user) {
      return ctx.unauthorized('You must be logged in to accept an invitation');
    }

    const invitation = await strapi.services.invitation.findOne({ token });
    if (!invitation) {
      return ctx.notFound('Invitation not found');
    }

    if (invitation.status !== 'pending') {
      return ctx.badRequest('This invitation has already been processed');
    }

    // Update invitation status
    await strapi.services.invitation.update(
      { id: invitation.id },
      { status: 'accepted' }
    );

    // Add user to organization
    await strapi.services.organisation.update(
      { id: invitation.organization.id },
      { users: [...invitation.organization.users, user.id] }
    );

    return { message: 'Invitation accepted successfully' };
  },

  async list(ctx) {
    const user = ctx.state.user;

    if (!user) {
      return ctx.unauthorized('You must be logged in to view invitations');
    }

    // This assumes you have a way to check if a user is an admin of an organization
    // You might need to adjust this based on your permission structure
    const invitations = await strapi.services.invitation.find({
      invitedBy: user.id,
      status: 'pending'
    });

    return invitations.map(invitation => sanitizeEntity(invitation, { model: strapi.models.invitation }));
  }
};

================
File: src/api/invitation/routes/invitation.js
================
'use strict';
'use strict';

module.exports = {
  routes: [
    {
      method: 'GET',
      path: '/invitations',
      handler: 'invitation.find',
      config: {
        policies: [],
        middlewares: [],
      },
    },
    {
      method: 'POST',
      path: '/invitations',
      handler: 'invitation.create',
      config: {
        policies: [],
        middlewares: [],
      },
    },
    {
      method: 'PUT',
      path: '/invitations/:token/accept',
      handler: 'invitation.accept',
      config: {
        policies: [],
        middlewares: [],
      },
    },
  ],
};

================
File: src/api/invitation/services/invitation.js
================
'use strict';

/**
 * invitation service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::invitation.invitation');

================
File: src/api/organisation/content-types/organisation/schema.json
================
{
  "kind": "collectionType",
  "collectionName": "organisations",
  "info": {
    "singularName": "organisation",
    "pluralName": "organisations",
    "displayName": "Organisation",
    "description": ""
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "name": {
      "type": "string"
    },
    "description": {
      "type": "text"
    },
    "size": {
      "type": "string"
    },
    "location": {
      "type": "string"
    },
    "users": {
      "type": "relation",
      "relation": "manyToMany",
      "target": "plugin::users-permissions.user",
      "inversedBy": "organisations"
    },
    "seat_type": {
      "type": "relation",
      "relation": "oneToOne",
      "target": "api::seat-type.seat-type"
    },
    "country": {
      "type": "string"
    },
    "admins": {
      "type": "relation",
      "relation": "manyToMany",
      "target": "plugin::users-permissions.user",
      "inversedBy": "adminOf"
    },
    "invitations": {
      "type": "relation",
      "relation": "oneToMany",
      "target": "api::invitation.invitation",
      "mappedBy": "organisation"
    },
    "channels": {
      "type": "relation",
      "relation": "oneToMany",
      "target": "api::channel.channel",
      "mappedBy": "organisation"
    }
  }
}

================
File: src/api/organisation/controllers/organisation.js
================
'use strict';

/**
 * organisation controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::organisation.organisation');

================
File: src/api/organisation/routes/organisation.js
================
'use strict';

/**
 * organisation router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::organisation.organisation');

================
File: src/api/organisation/services/organisation.js
================
'use strict';

/**
 * organisation service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::organisation.organisation');

================
File: src/api/seat-type/content-types/seat-type/schema.json
================
{
  "kind": "collectionType",
  "collectionName": "seat_types",
  "info": {
    "singularName": "seat-type",
    "pluralName": "seat-types",
    "displayName": "SeatType",
    "description": ""
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "name": {
      "type": "string"
    },
    "price": {
      "type": "string"
    },
    "maxNumberOfSeats": {
      "type": "integer"
    },
    "seatsRange": {
      "type": "string"
    },
    "pricePerSeat": {
      "type": "string"
    },
    "storagePrice": {
      "type": "string"
    },
    "maxStorage": {
      "type": "string"
    },
    "maxChannels": {
      "type": "integer"
    },
    "description": {
      "type": "text"
    }
  }
}

================
File: src/api/seat-type/controllers/seat-type.js
================
'use strict';

/**
 * seat-type controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::seat-type.seat-type');

================
File: src/api/seat-type/routes/seat-type.js
================
'use strict';

/**
 * seat-type router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::seat-type.seat-type');

================
File: src/api/seat-type/services/seat-type.js
================
'use strict';

/**
 * seat-type service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::seat-type.seat-type');

================
File: src/extensions/users-permissions/content-types/user/schema.json
================
{
  "kind": "collectionType",
  "collectionName": "up_users",
  "info": {
    "name": "user",
    "description": "",
    "singularName": "user",
    "pluralName": "users",
    "displayName": "User"
  },
  "options": {
    "draftAndPublish": false
  },
  "attributes": {
    "username": {
      "type": "string",
      "minLength": 3,
      "unique": true,
      "configurable": false,
      "required": true
    },
    "email": {
      "type": "email",
      "minLength": 6,
      "configurable": false,
      "required": true
    },
    "provider": {
      "type": "string",
      "configurable": false
    },
    "password": {
      "type": "password",
      "minLength": 6,
      "configurable": false,
      "private": true,
      "searchable": false
    },
    "resetPasswordToken": {
      "type": "string",
      "configurable": false,
      "private": true,
      "searchable": false
    },
    "confirmationToken": {
      "type": "string",
      "configurable": false,
      "private": true,
      "searchable": false
    },
    "confirmed": {
      "type": "boolean",
      "default": false,
      "configurable": false
    },
    "blocked": {
      "type": "boolean",
      "default": false,
      "configurable": false
    },
    "role": {
      "type": "relation",
      "relation": "manyToOne",
      "target": "plugin::users-permissions.role",
      "inversedBy": "users",
      "configurable": false
    },
    "organisations": {
      "type": "relation",
      "relation": "manyToMany",
      "target": "api::organisation.organisation",
      "mappedBy": "users"
    },
    "firstName": {
      "type": "string"
    },
    "lastName": {
      "type": "string"
    },
    "adminOf": {
      "type": "relation",
      "relation": "manyToMany",
      "target": "api::organisation.organisation",
      "mappedBy": "admins"
    }
  }
}

================
File: src/index.js
================
'use strict';

module.exports = {
  /**
   * An asynchronous register function that runs before
   * your application is initialized.
   *
   * This gives you an opportunity to extend code.
   */
  register(/*{ strapi }*/) {},

  /**
   * An asynchronous bootstrap function that runs before
   * your application gets started.
   *
   * This gives you an opportunity to set up your data model,
   * run jobs, or perform some special logic.
   */
  bootstrap(/*{ strapi }*/) {},
};

================
File: types/generated/components.d.ts
================
import type { Schema, Attribute } from '@strapi/strapi';

declare module '@strapi/types' {
  export module Shared {}
}

================
File: types/generated/contentTypes.d.ts
================
import type { Schema, Attribute } from '@strapi/strapi';

export interface AdminPermission extends Schema.CollectionType {
  collectionName: 'admin_permissions';
  info: {
    name: 'Permission';
    description: '';
    singularName: 'permission';
    pluralName: 'permissions';
    displayName: 'Permission';
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    action: Attribute.String &
      Attribute.Required &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    actionParameters: Attribute.JSON & Attribute.DefaultTo<{}>;
    subject: Attribute.String &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    properties: Attribute.JSON & Attribute.DefaultTo<{}>;
    conditions: Attribute.JSON & Attribute.DefaultTo<[]>;
    role: Attribute.Relation<'admin::permission', 'manyToOne', 'admin::role'>;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'admin::permission',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'admin::permission',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface AdminUser extends Schema.CollectionType {
  collectionName: 'admin_users';
  info: {
    name: 'User';
    description: '';
    singularName: 'user';
    pluralName: 'users';
    displayName: 'User';
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    firstname: Attribute.String &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    lastname: Attribute.String &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    username: Attribute.String;
    email: Attribute.Email &
      Attribute.Required &
      Attribute.Private &
      Attribute.Unique &
      Attribute.SetMinMaxLength<{
        minLength: 6;
      }>;
    password: Attribute.Password &
      Attribute.Private &
      Attribute.SetMinMaxLength<{
        minLength: 6;
      }>;
    resetPasswordToken: Attribute.String & Attribute.Private;
    registrationToken: Attribute.String & Attribute.Private;
    isActive: Attribute.Boolean &
      Attribute.Private &
      Attribute.DefaultTo<false>;
    roles: Attribute.Relation<'admin::user', 'manyToMany', 'admin::role'> &
      Attribute.Private;
    blocked: Attribute.Boolean & Attribute.Private & Attribute.DefaultTo<false>;
    preferedLanguage: Attribute.String;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<'admin::user', 'oneToOne', 'admin::user'> &
      Attribute.Private;
    updatedBy: Attribute.Relation<'admin::user', 'oneToOne', 'admin::user'> &
      Attribute.Private;
  };
}

export interface AdminRole extends Schema.CollectionType {
  collectionName: 'admin_roles';
  info: {
    name: 'Role';
    description: '';
    singularName: 'role';
    pluralName: 'roles';
    displayName: 'Role';
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    name: Attribute.String &
      Attribute.Required &
      Attribute.Unique &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    code: Attribute.String &
      Attribute.Required &
      Attribute.Unique &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    description: Attribute.String;
    users: Attribute.Relation<'admin::role', 'manyToMany', 'admin::user'>;
    permissions: Attribute.Relation<
      'admin::role',
      'oneToMany',
      'admin::permission'
    >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<'admin::role', 'oneToOne', 'admin::user'> &
      Attribute.Private;
    updatedBy: Attribute.Relation<'admin::role', 'oneToOne', 'admin::user'> &
      Attribute.Private;
  };
}

export interface AdminApiToken extends Schema.CollectionType {
  collectionName: 'strapi_api_tokens';
  info: {
    name: 'Api Token';
    singularName: 'api-token';
    pluralName: 'api-tokens';
    displayName: 'Api Token';
    description: '';
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    name: Attribute.String &
      Attribute.Required &
      Attribute.Unique &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    description: Attribute.String &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }> &
      Attribute.DefaultTo<''>;
    type: Attribute.Enumeration<['read-only', 'full-access', 'custom']> &
      Attribute.Required &
      Attribute.DefaultTo<'read-only'>;
    accessKey: Attribute.String &
      Attribute.Required &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    lastUsedAt: Attribute.DateTime;
    permissions: Attribute.Relation<
      'admin::api-token',
      'oneToMany',
      'admin::api-token-permission'
    >;
    expiresAt: Attribute.DateTime;
    lifespan: Attribute.BigInteger;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'admin::api-token',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'admin::api-token',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface AdminApiTokenPermission extends Schema.CollectionType {
  collectionName: 'strapi_api_token_permissions';
  info: {
    name: 'API Token Permission';
    description: '';
    singularName: 'api-token-permission';
    pluralName: 'api-token-permissions';
    displayName: 'API Token Permission';
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    action: Attribute.String &
      Attribute.Required &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    token: Attribute.Relation<
      'admin::api-token-permission',
      'manyToOne',
      'admin::api-token'
    >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'admin::api-token-permission',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'admin::api-token-permission',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface AdminTransferToken extends Schema.CollectionType {
  collectionName: 'strapi_transfer_tokens';
  info: {
    name: 'Transfer Token';
    singularName: 'transfer-token';
    pluralName: 'transfer-tokens';
    displayName: 'Transfer Token';
    description: '';
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    name: Attribute.String &
      Attribute.Required &
      Attribute.Unique &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    description: Attribute.String &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }> &
      Attribute.DefaultTo<''>;
    accessKey: Attribute.String &
      Attribute.Required &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    lastUsedAt: Attribute.DateTime;
    permissions: Attribute.Relation<
      'admin::transfer-token',
      'oneToMany',
      'admin::transfer-token-permission'
    >;
    expiresAt: Attribute.DateTime;
    lifespan: Attribute.BigInteger;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'admin::transfer-token',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'admin::transfer-token',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface AdminTransferTokenPermission extends Schema.CollectionType {
  collectionName: 'strapi_transfer_token_permissions';
  info: {
    name: 'Transfer Token Permission';
    description: '';
    singularName: 'transfer-token-permission';
    pluralName: 'transfer-token-permissions';
    displayName: 'Transfer Token Permission';
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    action: Attribute.String &
      Attribute.Required &
      Attribute.SetMinMaxLength<{
        minLength: 1;
      }>;
    token: Attribute.Relation<
      'admin::transfer-token-permission',
      'manyToOne',
      'admin::transfer-token'
    >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'admin::transfer-token-permission',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'admin::transfer-token-permission',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface PluginUploadFile extends Schema.CollectionType {
  collectionName: 'files';
  info: {
    singularName: 'file';
    pluralName: 'files';
    displayName: 'File';
    description: '';
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    name: Attribute.String & Attribute.Required;
    alternativeText: Attribute.String;
    caption: Attribute.String;
    width: Attribute.Integer;
    height: Attribute.Integer;
    formats: Attribute.JSON;
    hash: Attribute.String & Attribute.Required;
    ext: Attribute.String;
    mime: Attribute.String & Attribute.Required;
    size: Attribute.Decimal & Attribute.Required;
    url: Attribute.String & Attribute.Required;
    previewUrl: Attribute.String;
    provider: Attribute.String & Attribute.Required;
    provider_metadata: Attribute.JSON;
    related: Attribute.Relation<'plugin::upload.file', 'morphToMany'>;
    folder: Attribute.Relation<
      'plugin::upload.file',
      'manyToOne',
      'plugin::upload.folder'
    > &
      Attribute.Private;
    folderPath: Attribute.String &
      Attribute.Required &
      Attribute.Private &
      Attribute.SetMinMax<
        {
          min: 1;
        },
        number
      >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'plugin::upload.file',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'plugin::upload.file',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface PluginUploadFolder extends Schema.CollectionType {
  collectionName: 'upload_folders';
  info: {
    singularName: 'folder';
    pluralName: 'folders';
    displayName: 'Folder';
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    name: Attribute.String &
      Attribute.Required &
      Attribute.SetMinMax<
        {
          min: 1;
        },
        number
      >;
    pathId: Attribute.Integer & Attribute.Required & Attribute.Unique;
    parent: Attribute.Relation<
      'plugin::upload.folder',
      'manyToOne',
      'plugin::upload.folder'
    >;
    children: Attribute.Relation<
      'plugin::upload.folder',
      'oneToMany',
      'plugin::upload.folder'
    >;
    files: Attribute.Relation<
      'plugin::upload.folder',
      'oneToMany',
      'plugin::upload.file'
    >;
    path: Attribute.String &
      Attribute.Required &
      Attribute.SetMinMax<
        {
          min: 1;
        },
        number
      >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'plugin::upload.folder',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'plugin::upload.folder',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface PluginContentReleasesRelease extends Schema.CollectionType {
  collectionName: 'strapi_releases';
  info: {
    singularName: 'release';
    pluralName: 'releases';
    displayName: 'Release';
  };
  options: {
    draftAndPublish: false;
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    name: Attribute.String & Attribute.Required;
    releasedAt: Attribute.DateTime;
    scheduledAt: Attribute.DateTime;
    timezone: Attribute.String;
    status: Attribute.Enumeration<
      ['ready', 'blocked', 'failed', 'done', 'empty']
    > &
      Attribute.Required;
    actions: Attribute.Relation<
      'plugin::content-releases.release',
      'oneToMany',
      'plugin::content-releases.release-action'
    >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'plugin::content-releases.release',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'plugin::content-releases.release',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface PluginContentReleasesReleaseAction
  extends Schema.CollectionType {
  collectionName: 'strapi_release_actions';
  info: {
    singularName: 'release-action';
    pluralName: 'release-actions';
    displayName: 'Release Action';
  };
  options: {
    draftAndPublish: false;
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    type: Attribute.Enumeration<['publish', 'unpublish']> & Attribute.Required;
    entry: Attribute.Relation<
      'plugin::content-releases.release-action',
      'morphToOne'
    >;
    contentType: Attribute.String & Attribute.Required;
    locale: Attribute.String;
    release: Attribute.Relation<
      'plugin::content-releases.release-action',
      'manyToOne',
      'plugin::content-releases.release'
    >;
    isEntryValid: Attribute.Boolean;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'plugin::content-releases.release-action',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'plugin::content-releases.release-action',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface PluginI18NLocale extends Schema.CollectionType {
  collectionName: 'i18n_locale';
  info: {
    singularName: 'locale';
    pluralName: 'locales';
    collectionName: 'locales';
    displayName: 'Locale';
    description: '';
  };
  options: {
    draftAndPublish: false;
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    name: Attribute.String &
      Attribute.SetMinMax<
        {
          min: 1;
          max: 50;
        },
        number
      >;
    code: Attribute.String & Attribute.Unique;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'plugin::i18n.locale',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'plugin::i18n.locale',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface PluginUsersPermissionsPermission
  extends Schema.CollectionType {
  collectionName: 'up_permissions';
  info: {
    name: 'permission';
    description: '';
    singularName: 'permission';
    pluralName: 'permissions';
    displayName: 'Permission';
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    action: Attribute.String & Attribute.Required;
    role: Attribute.Relation<
      'plugin::users-permissions.permission',
      'manyToOne',
      'plugin::users-permissions.role'
    >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'plugin::users-permissions.permission',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'plugin::users-permissions.permission',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface PluginUsersPermissionsRole extends Schema.CollectionType {
  collectionName: 'up_roles';
  info: {
    name: 'role';
    description: '';
    singularName: 'role';
    pluralName: 'roles';
    displayName: 'Role';
  };
  pluginOptions: {
    'content-manager': {
      visible: false;
    };
    'content-type-builder': {
      visible: false;
    };
  };
  attributes: {
    name: Attribute.String &
      Attribute.Required &
      Attribute.SetMinMaxLength<{
        minLength: 3;
      }>;
    description: Attribute.String;
    type: Attribute.String & Attribute.Unique;
    permissions: Attribute.Relation<
      'plugin::users-permissions.role',
      'oneToMany',
      'plugin::users-permissions.permission'
    >;
    users: Attribute.Relation<
      'plugin::users-permissions.role',
      'oneToMany',
      'plugin::users-permissions.user'
    >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'plugin::users-permissions.role',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'plugin::users-permissions.role',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface PluginUsersPermissionsUser extends Schema.CollectionType {
  collectionName: 'up_users';
  info: {
    name: 'user';
    description: '';
    singularName: 'user';
    pluralName: 'users';
    displayName: 'User';
  };
  options: {
    draftAndPublish: false;
  };
  attributes: {
    username: Attribute.String &
      Attribute.Required &
      Attribute.Unique &
      Attribute.SetMinMaxLength<{
        minLength: 3;
      }>;
    email: Attribute.Email &
      Attribute.Required &
      Attribute.SetMinMaxLength<{
        minLength: 6;
      }>;
    provider: Attribute.String;
    password: Attribute.Password &
      Attribute.Private &
      Attribute.SetMinMaxLength<{
        minLength: 6;
      }>;
    resetPasswordToken: Attribute.String & Attribute.Private;
    confirmationToken: Attribute.String & Attribute.Private;
    confirmed: Attribute.Boolean & Attribute.DefaultTo<false>;
    blocked: Attribute.Boolean & Attribute.DefaultTo<false>;
    role: Attribute.Relation<
      'plugin::users-permissions.user',
      'manyToOne',
      'plugin::users-permissions.role'
    >;
    organisations: Attribute.Relation<
      'plugin::users-permissions.user',
      'manyToMany',
      'api::organisation.organisation'
    >;
    firstName: Attribute.String;
    lastName: Attribute.String;
    adminOf: Attribute.Relation<
      'plugin::users-permissions.user',
      'manyToMany',
      'api::organisation.organisation'
    >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'plugin::users-permissions.user',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'plugin::users-permissions.user',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface ApiChannelChannel extends Schema.CollectionType {
  collectionName: 'channels';
  info: {
    singularName: 'channel';
    pluralName: 'channels';
    displayName: 'Channel';
    description: '';
  };
  options: {
    draftAndPublish: true;
  };
  attributes: {
    name: Attribute.String;
    description: Attribute.Text;
    organisation: Attribute.Relation<
      'api::channel.channel',
      'manyToOne',
      'api::organisation.organisation'
    >;
    users: Attribute.Relation<
      'api::channel.channel',
      'oneToMany',
      'plugin::users-permissions.user'
    >;
    invitations: Attribute.Relation<
      'api::channel.channel',
      'oneToMany',
      'api::channel-invitation.channel-invitation'
    >;
    isInternal: Attribute.Boolean & Attribute.DefaultTo<false>;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    publishedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'api::channel.channel',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'api::channel.channel',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface ApiChannelInvitationChannelInvitation
  extends Schema.CollectionType {
  collectionName: 'channel_invitations';
  info: {
    singularName: 'channel-invitation';
    pluralName: 'channel-invitations';
    displayName: 'Channel Invitation';
  };
  options: {
    draftAndPublish: false;
  };
  attributes: {
    email: Attribute.Email & Attribute.Required;
    channel: Attribute.Relation<
      'api::channel-invitation.channel-invitation',
      'manyToOne',
      'api::channel.channel'
    >;
    status: Attribute.Enumeration<['pending', 'accepted', 'rejected']> &
      Attribute.DefaultTo<'pending'>;
    token: Attribute.String & Attribute.Unique;
    invitedBy: Attribute.Relation<
      'api::channel-invitation.channel-invitation',
      'manyToOne',
      'plugin::users-permissions.user'
    >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'api::channel-invitation.channel-invitation',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'api::channel-invitation.channel-invitation',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface ApiCountryCountry extends Schema.CollectionType {
  collectionName: 'countries';
  info: {
    singularName: 'country';
    pluralName: 'countries';
    displayName: 'Country';
  };
  options: {
    draftAndPublish: true;
  };
  attributes: {
    name: Attribute.String;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    publishedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'api::country.country',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'api::country.country',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface ApiInvitationInvitation extends Schema.CollectionType {
  collectionName: 'invitations';
  info: {
    singularName: 'invitation';
    pluralName: 'invitations';
    displayName: 'Invitation';
  };
  options: {
    draftAndPublish: false;
  };
  attributes: {
    email: Attribute.Email & Attribute.Required;
    organisation: Attribute.Relation<
      'api::invitation.invitation',
      'manyToOne',
      'api::organisation.organisation'
    >;
    invitedBy: Attribute.Relation<
      'api::invitation.invitation',
      'manyToOne',
      'plugin::users-permissions.user'
    >;
    status: Attribute.Enumeration<['pending', 'accepted', 'rejected']> &
      Attribute.DefaultTo<'pending'>;
    token: Attribute.String & Attribute.Unique;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'api::invitation.invitation',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'api::invitation.invitation',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface ApiOrganisationOrganisation extends Schema.CollectionType {
  collectionName: 'organisations';
  info: {
    singularName: 'organisation';
    pluralName: 'organisations';
    displayName: 'Organisation';
    description: '';
  };
  options: {
    draftAndPublish: true;
  };
  attributes: {
    name: Attribute.String;
    description: Attribute.Text;
    size: Attribute.String;
    location: Attribute.String;
    users: Attribute.Relation<
      'api::organisation.organisation',
      'manyToMany',
      'plugin::users-permissions.user'
    >;
    seat_type: Attribute.Relation<
      'api::organisation.organisation',
      'oneToOne',
      'api::seat-type.seat-type'
    >;
    country: Attribute.String;
    admins: Attribute.Relation<
      'api::organisation.organisation',
      'manyToMany',
      'plugin::users-permissions.user'
    >;
    invitations: Attribute.Relation<
      'api::organisation.organisation',
      'oneToMany',
      'api::invitation.invitation'
    >;
    channels: Attribute.Relation<
      'api::organisation.organisation',
      'oneToMany',
      'api::channel.channel'
    >;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    publishedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'api::organisation.organisation',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'api::organisation.organisation',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

export interface ApiSeatTypeSeatType extends Schema.CollectionType {
  collectionName: 'seat_types';
  info: {
    singularName: 'seat-type';
    pluralName: 'seat-types';
    displayName: 'SeatType';
    description: '';
  };
  options: {
    draftAndPublish: true;
  };
  attributes: {
    name: Attribute.String;
    price: Attribute.String;
    maxNumberOfSeats: Attribute.Integer;
    seatsRange: Attribute.String;
    pricePerSeat: Attribute.String;
    storagePrice: Attribute.String;
    maxStorage: Attribute.String;
    maxChannels: Attribute.Integer;
    description: Attribute.Text;
    createdAt: Attribute.DateTime;
    updatedAt: Attribute.DateTime;
    publishedAt: Attribute.DateTime;
    createdBy: Attribute.Relation<
      'api::seat-type.seat-type',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
    updatedBy: Attribute.Relation<
      'api::seat-type.seat-type',
      'oneToOne',
      'admin::user'
    > &
      Attribute.Private;
  };
}

declare module '@strapi/types' {
  export module Shared {
    export interface ContentTypes {
      'admin::permission': AdminPermission;
      'admin::user': AdminUser;
      'admin::role': AdminRole;
      'admin::api-token': AdminApiToken;
      'admin::api-token-permission': AdminApiTokenPermission;
      'admin::transfer-token': AdminTransferToken;
      'admin::transfer-token-permission': AdminTransferTokenPermission;
      'plugin::upload.file': PluginUploadFile;
      'plugin::upload.folder': PluginUploadFolder;
      'plugin::content-releases.release': PluginContentReleasesRelease;
      'plugin::content-releases.release-action': PluginContentReleasesReleaseAction;
      'plugin::i18n.locale': PluginI18NLocale;
      'plugin::users-permissions.permission': PluginUsersPermissionsPermission;
      'plugin::users-permissions.role': PluginUsersPermissionsRole;
      'plugin::users-permissions.user': PluginUsersPermissionsUser;
      'api::channel.channel': ApiChannelChannel;
      'api::channel-invitation.channel-invitation': ApiChannelInvitationChannelInvitation;
      'api::country.country': ApiCountryCountry;
      'api::invitation.invitation': ApiInvitationInvitation;
      'api::organisation.organisation': ApiOrganisationOrganisation;
      'api::seat-type.seat-type': ApiSeatTypeSeatType;
    }
  }
}

================
File: .editorconfig
================
root = true

[*]
indent_style = space
indent_size = 2
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[{package.json,*.yml}]
indent_style = space
indent_size = 2

[*.md]
trim_trailing_whitespace = false

================
File: .env.example
================
HOST=0.0.0.0
PORT=1337
APP_KEYS="toBeModified1,toBeModified2"
API_TOKEN_SALT=tobemodified
ADMIN_JWT_SECRET=tobemodified
TRANSFER_TOKEN_SALT=tobemodified
JWT_SECRET=tobemodified

================
File: .eslintignore
================
.cache
build
**/node_modules/**

================
File: .eslintrc
================
{
  "parser": "babel-eslint",
  "extends": "eslint:recommended",
  "env": {
    "commonjs": true,
    "es6": true,
    "node": true,
    "browser": false
  },
  "parserOptions": {
    "ecmaFeatures": {
      "experimentalObjectRestSpread": true,
      "jsx": false
    },
    "sourceType": "module"
  },
  "globals": {
    "strapi": true
  },
  "rules": {
    "indent": ["error", 2, { "SwitchCase": 1 }],
    "linebreak-style": ["error", "unix"],
    "no-console": 0,
    "quotes": ["error", "single"],
    "semi": ["error", "always"]
  }
}

================
File: .gitignore
================
############################
# OS X
############################

.DS_Store
.AppleDouble
.LSOverride
Icon
.Spotlight-V100
.Trashes
._*


############################
# Linux
############################

*~


############################
# Windows
############################

Thumbs.db
ehthumbs.db
Desktop.ini
$RECYCLE.BIN/
*.cab
*.msi
*.msm
*.msp


############################
# Packages
############################

*.7z
*.csv
*.dat
*.dmg
*.gz
*.iso
*.jar
*.rar
*.tar
*.zip
*.com
*.class
*.dll
*.exe
*.o
*.seed
*.so
*.swo
*.swp
*.swn
*.swm
*.out
*.pid


############################
# Logs and databases
############################

.tmp
*.log
*.sql
*.sqlite
*.sqlite3


############################
# Misc.
############################

*#
ssl
.idea
nbproject
public/uploads/*
!public/uploads/.gitkeep

############################
# Node.js
############################

lib-cov
lcov.info
pids
logs
results
node_modules
.node_history

############################
# Tests
############################

coverage

############################
# Strapi
############################

.env
license.txt
exports
.strapi
dist
build
.strapi-updater.json

================
File: jsconfig.json
================
{
  "compilerOptions": {
    "moduleResolution": "nodenext",
    "target": "ES2021",
    "checkJs": true,
    "allowJs": true
  }
}

================
File: package.json
================
{
  "name": "orchard",
  "private": true,
  "version": "0.1.0",
  "description": "A Strapi application",
  "scripts": {
    "develop": "strapi develop",
    "start": "strapi start",
    "build": "strapi build",
    "strapi": "strapi"
  },
  "dependencies": {
    "@strapi/plugin-cloud": "4.24.4",
    "@strapi/plugin-i18n": "4.24.4",
    "@strapi/plugin-users-permissions": "4.24.4",
    "@strapi/provider-email-sendgrid": "^4.25.8",
    "@strapi/strapi": "4.24.4",
    "@strapi/utils": "^4.25.10",
    "better-sqlite3": "8.6.0",
    "pg": "^8.12.0",
    "react": "^18.0.0",
    "react-dom": "^18.0.0",
    "react-router-dom": "5.3.4",
    "strapi-plugin-netlify-deployments": "^2.0.2",
    "styled-components": "5.3.3"
  },
  "author": {
    "name": "A Strapi developer"
  },
  "strapi": {
    "uuid": "70fb6dba-c696-4fbf-a45c-2f3e8a216631"
  },
  "engines": {
    "node": ">=18.0.0 <=20.x.x",
    "npm": ">=6.0.0"
  },
  "license": "MIT"
}

================
File: README.md
================
#  Getting started with Strapi

Strapi comes with a full featured [Command Line Interface](https://docs.strapi.io/dev-docs/cli) (CLI) which lets you scaffold and manage your project in seconds.

### `develop`

Start your Strapi application with autoReload enabled. [Learn more](https://docs.strapi.io/dev-docs/cli#strapi-develop)

```
npm run develop
# or
yarn develop
```

### `start`

Start your Strapi application with autoReload disabled. [Learn more](https://docs.strapi.io/dev-docs/cli#strapi-start)

```
npm run start
# or
yarn start
```

### `build`

Build your admin panel. [Learn more](https://docs.strapi.io/dev-docs/cli#strapi-build)

```
npm run build
# or
yarn build
```

##  Deployment

Strapi gives you many possible deployment options for your project including [Strapi Cloud](https://cloud.strapi.io). Browse the [deployment section of the documentation](https://docs.strapi.io/dev-docs/deployment) to find the best solution for your use case.

##  Learn more

- [Resource center](https://strapi.io/resource-center) - Strapi resource center.
- [Strapi documentation](https://docs.strapi.io) - Official Strapi documentation.
- [Strapi tutorials](https://strapi.io/tutorials) - List of tutorials made by the core team and the community.
- [Strapi blog](https://strapi.io/blog) - Official Strapi blog containing articles made by the Strapi team and the community.
- [Changelog](https://strapi.io/changelog) - Find out about the Strapi product updates, new features and general improvements.

Feel free to check out the [Strapi GitHub repository](https://github.com/strapi/strapi). Your feedback and contributions are welcome!

##  Community

- [Discord](https://discord.strapi.io) - Come chat with the Strapi community including the core team.
- [Forum](https://forum.strapi.io/) - Place to discuss, ask questions and find answers, show your Strapi project and get feedback or just talk with other Community members.
- [Awesome Strapi](https://github.com/strapi/awesome-strapi) - A curated list of awesome things related to Strapi.

---

<sub> Psst! [Strapi is hiring](https://strapi.io/careers).</sub>
